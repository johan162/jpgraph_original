<small>Version: $Id: index.html,v 1.2 2002/09/17 21:52:45 aditus Exp $ </small>
<div align=center>
<h2>PHP Database Driven Documentation Architecture (PHP DDDA)</h2>
</div>

<div align=center>Johan Persson (johanp@aditus.nu)<br>Aditus Software</div>
&nbsp;
<p>

<div align=center><font face=arial><b><i>Abstract</i></b></font></div>
<i>
Here we present a new MySQL based documentation system for PHP.
The proposed architecture, DDDA, combines the best features from
automatic source code documentation system like doxygen with 
traditional hand crafted documentation. The benefit of this system
is that it will clearly separate user level documentation 
from system level documentation and thereby keeping the code base
clean. The system also allows easy generation of weighted documentation 
statistics which might be used to generate objective progess 
indication and help focus the documentation effort on 
underdocumented parts of the system.
</i>

<h2>1. Introduction and motivation</h2>
The first question anybody reading this will ask is probably:
<p>
<i>"Why  another documentation system when there are already 
automatic system in existence?" </i>
<p>
To answer that question let's
first think of who are the target of the class documentation. 
At one hand you have the user who wants user level description
and examples. On the other hand maintainers of the class also
needs a further level of internal system documentation which
is of little use for the end user.
<p>
For the maintainer of the class the code itself should contain
necessary code level comments together with suitable architectural
overviews. For the end user the documentation
should be provided entirely external to the code. Current automatic 
system insists on keeping all documentation in the source itself 
from where it later can be extracted to produce documentation.
<p>
The problem with these system is that the code gets cluttered
with a lot of user level documentation which 
makes the code difficult to navigate in. 
<p>
On the other hand an automatic system has the advantage that
it can extract class information automatically (like class 
hierarchies and function prototypes) which is always tedious
and error prone to copy&paste manually.
<p> 
The proposed system combines the two methods by 
first automatically extract
all class information storing it in a database and
then let the developer augment that database with
suitable user level description of classes and methods.
<p>
Now, whenever the code is modified the automatic extraction
is just re-run and the class hierarchy gets automatically adjusted.
Existing description and examples in the DB are preserved.
<p>
The documentation can then be automatically generated from
that DB. By applying different formatting modules different
types of documents can of course be generated.
<p>
An overview of the proposed system is shown in Figure 1.

<div align="center"><img src="img/docoverview.png"></div>
<div align=center><b>Fig 1.</b> Schematic overview of the DDDA architecture.</div>

<p>
An additional (almost accidental) feature that has proven 
useful in practice is the fact that
having all the information in a database makes it easy to
generate static's on the state of documentation. For example,
we can easily see how many percent of the public APIs that
are documented. This is very useful for tracking the progress
of documentation and making sure that the effort spend documenting
is directed to the most needing classes. 

<h2>2. Overview PHP DDDA</h2>

In this section we will give an overview of each of the three
different subsystems, the parser subsystem, the augmenting subsystem and the
report generating subsystem. These three systems together 
makes up the whole of the DDDA architecture. 
Where appropriate we will also give some further details.

<h3>2.1 Parser subsystem</h3>
The heart of the system is the PHP parser implemented in class 
Parser. It scans a given source file and extract all classes,
instance variables and functions declaration (including arguments). 
In addition to this information gathering it also performs
some rudimentary static analysis of the code. Specifically it 
checks for unused instance variables and warns for the case 
where the programmer might have intended to access an instance
variable but forgot to add '$this->'. (Which is a mistake that has
caused this author some less than well-spend debugging time.)
<p>
Since the class Parser is a generic parser class it doesn't know
anything about databases so the actual work is done by the
subclass DBParser which extends Parser and provides appropriate
factory functions to handle the interface to the DB. The way this 
works is that the Parser class provides "virtual" functions which
can easily be overridden by the appropriate sub class. By "plugging" in 
to the Parser framework it is very easy to adapt it to specific needs
in a very clean way without having to be intimate familiar with the
inner workings of the Parser.
<p>
All database access is done through a DB server object which is
responsible for all aspects of DB access. 
Class DBServer hence which provides functionality to access and query a
MySQL DB in various ways. In addition to the server object each query
is returned as an instance of class DBResult which is then used
by a client to manipulate and extract information from the result of a 
query. The relationship between the classes involved with the parsing 
aspect of the DDDA system is illustrated in
Figure 2. below.
<p>

<div align="center"><img src="img/parseclass.png"></div>
<div align=center><b>Fig 2.</b>Class relationship for the parsing functionality of the 
DDDA
architecture.</div>
<p>

Since all this functionality is implemented in a PHP script the script 
needs an entry point. To handle this each script has it's own driver
object. This object is responsible for initialization and extracting
possible script variables (such as arguments in a URL specification).
By convention all script execution is kicked off by the predefined
Run() method in the driver.


<h3>2.2 Database augmenting subsystem</h3>
Once all class data has been gathered and stored in the DB it is
time for the programmer to add his intelligent description of all
the classes and methods as well as adding suitable examples. 
This is all handled by the Database augmenting subsystem.
<p>
This consists of a number of forms to modify/edit data
for classes and methods as well as an index page to navigate and 
chose the class/method to work on. 
<p>
The interface is completely WEB based and
starts with an overview of all stored classes and methods in the BD
from where you drill down to the class/method you want to edit.
In version 1.0 of DDDA this interface is fairly basic and some
more creative use of JavaScript and DHTML is probably not a 
bad thing. However, due to time constrains, DDDA 1.0 mainly focus
on functionality rather than a lot of "fancy" WEB programming. 
This is also a thing that very easily can be added as a front 
end cosmetic "thingy" later on.
<p>
Once the programmer/documenter has chosen the class/method
to edit he is presented with a standard WEB-form with all
the static information about the class/method. He can then just
add suitable description and examples. 
<p>
The overall class hierarchy for the augment subsystem is shown in Figure 3. below.
<p>
<div align="center"><img src="img/augclass.png"></div>
<div align=center><b>Fig 3.</b>Class relationship for the class augmenting 
framework.</div>
<p>

As was previously mentioned it was found that the ability to generate 
statistics is quite useful to direct attention to less than well
documented areas. It has also proven as a very good way of actually
keeping track of the documentation status in a very measurable well.
<p>

All statistical processing is centralized in the
class DocStat. The static's is based on a point system where each class
(and method) receives a certain number of points based on the level
of documentation. The points system is weighted so that a class overview
is considered much more important than a forgotten comment for a single
method parameter. The actual points are than compared to the maximum 
achievable for that class (or method) to generated a percent figure.


<h3>2.2.1 The form layout engine</h3>
During developing of augmenting subsystem of the system 
it was realized that a generic system for generating form layout 
code together with the necessary DB queries based on the specified fields and 
DB table would be very useful and 
later on save time when modifying the forms. Hence the
creation of a specific form layout class. This now form the basis
of all form handling. A quick overview is given in this section.
<p>
The DB edit and layout enginge (class DBTableEdit and class FormLayout)
automatically generates code to edit a 
specified table, row by row. It takes care of both generating the actual
HTML as well as the necessary logic to handle the form submitting and DB
handling. The layout of the form is specified
by giving the specified row and column for each field that should 
be in the form together with the type for the field and some additional
layout parameters. There are 8 compulsory and 2 optional parameters 
necessary to specify one input cell. The parameters are as follows
<p>
<table border=1>
<tr><th>Parameter</th><th>Explanation</th></tr>
<tr><td>dbfield-name
</td><td>
The name of the database field that corresponds to this form field. Note that
by convention the actual field in the DB has the name 'fld_' as prefix to this
name.
</td></tr>
<tr><td>row
</td><td>
Which row in the form this field should appear in.
</td></tr>
<tr><td>col
</td><td>
Which column in the form this field should appear in.
</td></tr>
<tr><td>span
</td><td>
How many columns this field should span
</td></tr>
<tr><td>label-text
</td><td>
The text label to be shown close to this field in a way specified by the next parameter
</td></tr>
<tr><td>label-align
</td><td>
Specifies if the label should be shown above the field or to the left of the 
field.
</td></tr>
<tr><td>fld-align
</td><td>
Specifies if the field should be aligned to left or right in the cell
</td></tr>
<tr><td>fld-type</td><td>
What type of field should this be. Possible types are:
<table>
<tr><td>FLDTYPE_TEXTINPUT
</td><td>
Normal textinput. Field arguments are field length and maxlength
</td></tr>
<tr><td>FLDTYPE_TEXTAREA
</td><td>
Textarea input. Field arguments are size in columns and rows
</td></tr>
<tr><td>FLDTYPE_DROPDOWN
</td><td>
A dropdown listbox. Fieldargument is first a vector of the possible
values to display. The value retuned is the same as the displayed text.
</td></tr>
<tr><td>FLDTYPE_DROPDOWNCODE
</td><td>
Similair to FLDTYPE_DROPDOWN but with the difference that the supplied
vector must both have a display value and code value for each entry. This 
means that the vealue stored in the DB can be different from the displayed
value.
</td></tr>
<tr><td>FLDTYPE_STATICTEXT
</td><td>
Display non-edible static text
</td></tr>
<tr><td>FLDTYPE_STATICTEXTCODE
</td><td>
Similair to FLDTYPE_STATICTEXT but with the difference that the DB stores
a code value which is translated to a displayed text by the vector passed as
the first field argument.
</td></tr>
<tr><td>FLDTYPE_NONDBTEXT
</td><td>
A field that has nothing to do with the DB. Can display arbitrary text either
as a static supplied value as the first fieldargument or in the call to display
form.
</td></tr>
<tr><td>FLDTYPE_TIMESTAMP
</td><td>
Type is a MySQL timestamp which gets translated to a nice human readable 
string.
</td></tr>
<tr><td>FLDTYPE_RADIO
</td><td>Display as a radiobuttob. The values will be the same as the displayed
text and should be supplied as an array in the first fieldtype specific argument. 
To limit the number of radiobuttons per row a maximum number of columns can be 
given as the second argument.
</td></tr>
<tr><td>FLDTYPE_RADIOCODE
</td><td>
Same as FLDTYPE_RADIO but with the change that for each radiobutton 
the array should supply both a displaty value and code value.
</td></tr>
<tr><td>FLDTYPE_CHECK
</td><td>
A single check box. The value to be used can be specified as the first
argument. If not explicitly set the value '1' will be used.
</td></tr>
</table>
</td></tr>
<tr><td>fld-arg1
</td><td>
The first fieldtype specific argument.
</td></tr>
<tr><td>fld-arg2
</td><td>
The second fieldtype specific argument.
</td></tr>

</table>

<p>
For reasons of brievity we don't give a full description of all the details 
on how to use this as a standalone system instead we just give an example. 
Study the following specification (which happens to be a slightly modified
class editing form from the DDDA system)

<table border=1><tr><td>
<br>
&nbsp;
<small>
<font face=courier>
$formSpec = array(<br>
&nbsp;&nbsp;array('name',1,1,3,'',LBLPOS_LEFT,FLDPOS_LEFT,FLDTYPE_NONDBTEXT),
&nbsp;&nbsp;array('public',2,1,1,'',LBLPOS_LEFT,FLDPOS_LEFT,FLDTYPE_DROPDOWNCODE,$yn),			
&nbsp;&nbsp;array('file',2,2,1,'File:',LBLPOS_LEFT,FLDPOS_LEFT,FLDTYPE_STATICTEXT),			
&nbsp;&nbsp;array('linenbr',2,3,1,'#',LBLPOS_LEFT,FLDPOS_LEFT,FLDTYPE_STATICTEXT),
&nbsp;&nbsp;array('ref1',4,1,1,'Ref1:',LBLPOS_TOP,FLDPOS_LEFT,FLDTYPE_DROPDOWN,$cl),
&nbsp;&nbsp;array('ref2',4,2,1,'Ref2:',LBLPOS_TOP,FLDPOS_LEFT,FLDTYPE_DROPDOWN,$cl),
&nbsp;&nbsp;array('ref3',4,3,1,'Ref3:',LBLPOS_TOP,FLDPOS_LEFT,FLDTYPE_DROPDOWN,$cl),						
&nbsp;&nbsp;array('ref4',4,4,1,'Ref4:',LBLPOS_TOP,FLDPOS_LEFT,FLDTYPE_DROPDOWN,$cl),						
&nbsp;&nbsp;array('desc',3,1,4,'',LBLPOS_LEFT,FLDPOS_LEFT,FLDTYPE_TEXTAREA,70,5),			
&nbsp;&nbsp;array('timestamp',1,4,1,'',LBLPOS_LEFT,FLDPOS_LEFT,FLDTYPE_TIMESTAMP));
</font>
</small>
<br>
&nbsp;
</td></tr></table>
<p>
when given as specification it will generate the form shown in Figure 4 below.
<p>

<p>
<div align="center"><img src="img/formexample1.png"></div>
<div align=center><b>Fig 4.</b> Example of form generated by 
the previous given specification ("Spara" means "Save" in Swedish)</div>
<p>




<h3>2.3 Printing and formatting subsystem</h3>
Once all data is entered in the DB it is time to produce some
documents. The extraction of class and method data is all handled
by a framework which then uses a specific formatting plug in which
is responsible for producing the actual output.
<p>
In version 1.0 of DDDA we supply a basic HTML formatter plug in
which generates (surprise!) HTML in the form of a class reference.
<p>
In the future it is anticipated that 3:rd parties might supply 
PDF or RTF formatting plugins or even alternate HTML formatters.
<p>
The formatter plug in consist of a base class ClassFormatter which
have a number of virtual methods which the actual plug in must implement
in order to generate the output. These virtual methods will be automatically
called by the framework with specific information according to the basic
assumption of the layout of the code. These hooks will make it possible to
generate very different layout should you not be happy with the
supplied HTML formatter.
<p>
<div align="center"><img src="img/reportframework.png"></div>
<div align=center><b>Fig 5.</b>Class hierarchy for the report framework</div>
<p>
Since the report generator is responsible to generate a lot of
cross references which potentially could lead to unnecessary 
SQL queries and performance problems the report generator makes 
use of a DB Cache (class DBCache) which pre fetches the class 
and method information which dramatically increases performance. 


<h3>2.3.1 Visualizing inheritance in classes</h3>
It is worth mentioning the way class hierarchy is visualized. For each class
you will in the beginning of the class description see a list of all methods
that are part of this class in the form of a short table. If the class inherits
then this table will also show all the methods of the parent in another column. 
and so on. This way we can solve the problem of having an overview of 
available methods in classes that has long inheritance chains. When formatting
the method we use a special indication for methods that override a method in 
a super class. The overridden method in the super class is "grayed out" to better
visualize that the method is actually implemented by the subclass.
<p>
An example of this formatting style is given in Figure 6 below.
<p>
<table border=1><tr><td><b>&nbsp;RectPatternCross&nbsp;</b></td>
<td><b>&nbsp;RectPattern&nbsp;</b></td></tr><tr><td valign=top>&nbsp;<a 
href="#_RECTPATTERNCROSS_DOPATTERN">DoPattern()</a>&nbsp;<br>
&nbsp;<a 
href="#_RECTPATTERNCROSS_RECTPATTERNCROSS">RectPatternCross()</a>&
nbsp;<br>
&nbsp;<a 
href="#_RECTPATTERNCROSS_SETDENSITY">SetDensity()</a>&nbsp;<br>
&nbsp;<a href="#_RECTPATTERNCROSS_SETORDER">SetOrder()</a>&nbsp;<br>
&nbsp;<a href="#_RECTPATTERNCROSS_SETPOS">SetPos()</a>&nbsp;<br>
</td><td valign=top>&nbsp;<a 
href="#_RECTPATTERN_RECTPATTERN">RectPattern()</a>&nbsp;<br>
&nbsp;<a 
href="#_RECTPATTERN_SETBACKGROUND">SetBackground()</a>&nbsp;<br>
&nbsp;<font color=gray>SetDensity()&nbsp;</font><br>
&nbsp;<font color=gray>SetPos()&nbsp;</font><br>
&nbsp;<a href="#_RECTPATTERN_SHOWFRAME">ShowFrame()</a>&nbsp;<br>
&nbsp;<a href="#_RECTPATTERN_STROKE">Stroke()</a>&nbsp;<br>
</td></tr>
</table>
<div align=center><b>Fig 6.</b> Example how methods in a class are visualized, class 
RectPatternCross 
inherits from RectPattern. Observe that an
overridden method is "grayd-out". All methods are hyper linked which makes it easy to
quickly get a complete overview of the capabilities for a class. 
(Note that the links in the above example does NOT work since this table is taken 
directly from the real index)</div>

<h3>2.4 Database scheme</h3>

The database scheme doesn't reveal anything surprising. Each documentation 
project consists of three tables. One table for all methods, one for all
classes and finally one for all class variables. Global functions are
considered members of the "GLOBAL" class. In addition to these project 
specific tables there are two project tables used to keep track of all projects
and the files associated to each project. 
<p>
Some purists might argue
that storing both a foreign key and a foreign name is duplicate and that the
tables aren't normalized. However, this is by design to avoid table
lookups and slightly improve performance.

<br>&nbsp;
<div align="center"><img src="img/dbschema.png"></div>
<div align=center><b>Fig 7.</b> DDDA Database schema.</div>
<p>

Each table has a primary key "fld_key" and a timestamp "fld_timestamp" 
to keep track
of when the table row last was edited. We don't give detailed explanation
of each field here but instead refer the interested reader to the system
documentation. Most of the fields should be self-explanatory anyway.

<h3>3. Working with the system from a user perspective </h3>

The user interface is meny and form based making it relatively 
straightford to work with the system.
<p>
When first started the user is presented with the DDDA main meny as shown
below.

<div align="center"><img src="img/mainmeny.png"></div>
<div align=center><b>Fig 8.</b> DDDA Main meny.</div>
<p>

From this meny the user can choose to either create a new project or work on
an existing project. The first alternative is used to get an overview of an existing
project, the second to update the DB from the script files that makes up a project and
the last alternative to modify or create a project.

<h4> 3.1 Creating and modifying projects </h4>
 
After chosing the third meny alternative the user is presented with the
form to create a new project as illustrated in figure 9 below.

<div align="center"><img src="img/createproject.png"></div>
<div align=center><b>Fig 9.</b> The form to edit and create new projects.</div>
<p>

From the above form the user may eiter modify an existing project or create a new
one. 

<h4> 3.2 Working on existing projects </h4>

After choosing an existing project the user is presented with an overview of all
existing classes and methods in the project together with the percentage figures on the 
documentation as partly shown in figure 10 below.

<div align="center"><img src="img/projoverview.png"></div>
<div align=center><b>Fig 10.</b> Existing project. All the classes together with
the both the overall documentation status as well as the status of the 
individual classes. </div>
<p>


From this view the user may now choose to edit a specific class or method by
clicking on its name. The corresponding forms are displyed below in figure 12

<div align="center"><img src="img/editmethod.png"><img src="img/editclass.png"></div>
<div align=center><b>Fig 12.</b> Editing classes and methods.
 </div>
<p>


<h3>4. Conclusions and further enhancements</h3>

The system was first put to test to document JpGraph which is a medium 
complex php library consisting of around approx 10,000 loc. It has proven
to work well in practice. The obvious improvements is mainly 
WEB technicalities where the user interface  
could be improved. However that doesn't involve any functionality changes
but rather visual and navigational improvements.
<p>
In terms of future functional enhancements for the next version the plans
are to:
<ul>
<li>Enhance the parser to automatically recognize private and public
methods based on naming conventions.
<li>Add graphical statistics
<li>Adapt the UI to work with other than the Opera browser
</ul>
