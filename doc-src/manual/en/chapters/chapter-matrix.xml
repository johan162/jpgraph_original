<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<chapter
    version="5.0"
    xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xml:id="chapter.matrix-graphs">
    <title>Matrix graphs</title>
    <sect1>
        <title>Introduction</title>
        <note>
            <para>This module is only available in the pro-version of the library.</para>
        </note>
        <para>Matrix graphs are used to visualize the content of a rectangular matrix. Each entry in
            the matrix is mapped to a specific color which are then displayed in a rectangular plot
            corresponding to the size of the input matrix. The size of each module (corresponding to
            a matrix entry) is user customizable. There are two types of possible modules; circular
            and rectangular shape.</para>
        <para>In order to achieve high quality rendering when circles are used the matrix module
            makes use of an optional (user settable) super-sampling to achieve an anti-alias effect
            to take the edge of the filled circles.</para>
        <para>The color assignment to each value is controlled by the selected color map. The
            library first establish the min and max value in the matrix and then equates the min
            value with the "lower" end of the specified color map and the max value with the
            "higher" end of the color map. All values in between is linearly interpolated to a have
            a color between the "low" and "high" end in relation to the value (which are guaranteed
            to be between the min and max value previously established). There are several
            pre-defined color maps available as well as completely user configurable color maps. </para>
        <para>The (optional) legend shows the range associated to each color in the corresponding
            plot.</para>
        <para>
            <tip>
                <para>The library supports mesh interpolation. Mesh interpolation which by itself
                    doesn't produce any new data but can help produce smoother plots by creating
                    "false" interpolated values in between the original entries in the matrix. This
                    is similar to the Matlab (tm) command <command>interp2</command>
                </para>
            </tip>
        </para>
        <para>The overall structure and capabilities of matrix graphs follows that of other graphs
            in the library, e.g. Windrose plots, in that a graph can have multiple plots, title,
            footers, texts, icons, image backgrounds etc. <xref
                xlink:href="#fig.matrix_introex"/> shows a medium complex example of two matrix
            plots in a matrix graphs which uses both a background image, icon (the logo in the top
            left corner), timing of the graph and free positioned text. We have also used a small
            degree of alpha blending in the plots just to let the background "shine" through a
            little bit. The two plots shows the same data but uses different color maps.</para>
        <para>
            <programlisting>#=matrix_introex|A medium complex example to shows some capabilities of matrix plots#</programlisting>
        </para>
        <para>The library offers an extensive range of formatting for the appearance of the plot
            when it comes to adjusting exactly how the colors are used. There are several built in
            color maps as well as the possibility to specify manual color maps and adjusting the
            contrast (scale range) of the plot.</para>
        <sect2>
            <title>Features of the matrix plots</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>Both manual and automatic scale range setting</para>
                    </listitem>
                    <listitem>
                        <para>Customizable legend position and layout</para>
                    </listitem>
                    <listitem>
                        <para>Row and column legends (edge labels)</para>
                    </listitem>
                    <listitem>
                        <para>Several built in color maps (22)</para>
                    </listitem>
                    <listitem>
                        <para>Option for manual specified color maps</para>
                    </listitem>
                    <listitem>
                        <para>Adjustable color contrast</para>
                    </listitem>
                    <listitem>
                        <para>Layout classes to position multiple plots in the sam graph</para>
                    </listitem>
                    <listitem>
                        <para>Both circular and rectangular module type</para>
                    </listitem>
                    <listitem>
                        <para>Mesh interpolation of input data</para>
                    </listitem>
                    <listitem>
                        <para>Flexible sizing of matrix plots both manual, automatic and a mix of
                            them</para>
                    </listitem>
                    <listitem>
                        <para>Alpha blending support for matrix plot</para>
                    </listitem>
                    <listitem>
                        <para>All the usual graph support for background images, text objects and
                            icons</para>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Creating and formatting a basic matrix graph</title>
        <para>In order to create a matrix plot the extension module
                "<filename>jpgraph_matrix.php</filename>" must be included in the script along with
            the core module "<filename>jpgraph.php</filename>".</para>
        <para>The creation of Matrix graphs otherwise follows the traditional steps in the library
            of first creating a matrix graph which acts as a canvas for one or several matrix plots.
            The principle steps are:<orderedlist>
                <listitem>
                    <para>Create a basic matrix graph as an instance of <code>class
                            MatrixGraph</code> (in all our example we use the variable
                            <code>$graph</code> to hold this instance)</para>
                </listitem>
                <listitem>
                    <para>Create an instance of one or several matrix plots as instances of
                            <code>class MatrixPlot</code>, make any necessary modifications to the
                        color map and appearance and then add the plots to the matrix graph
                        canvas.</para>
                </listitem>
                <listitem>
                    <para>Send back the graph to the client with a call to
                            <code>MatrixGraph::Stroke()</code>. As usual this can be used to either
                        send back the graph to the client (e.g.browser) or write the graph to a file
                        by specifying a filename as the first argument to
                            <code>MatrixGraph::Stroke()</code>.</para>
                </listitem>
            </orderedlist></para>
        <para>The example in <xref
                xlink:href="#fig.matrix_ex0"/> shows a matrix plot using just the default values for
            all parameters. </para>
        <para>
            <programlisting>#matrix_ex0|A basic matrix graph with all default values#</programlisting>
        </para>
        <para>In the same way as for other graph types one or several Matrix plots can be added and
            positioned freely in the Matrix graph by specifying the position as either absolute
            coordinates or as fractions of the width/height of the overall graph.</para>
        <para>
            <tip>
                <para>An easier way to position Matrix plots is to use layout classes as described
                    in <xref
                        xlink:href="#sec.matrix-layout-classes"/></para>
            </tip>
        </para>
        <para>
            <tip>
                <para>If the data for the matrix is available in a file a convenient way to get hold
                    of the dat in the file is to use the utility <code>class ReadFileData</code> to
                    get hold of the data using the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>ReadFileData::FromMatrix($aFile,$aSeparator=' ')</code>
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>which read the matrix from a file. Each row of the matrix must be a separate
                    line and each cell is separated with the character specified as the second
                    argument. By default a space is used as separator. All values read back are
                    converted to floating point numbers (double precision). The following short
                    example shows how easy this is to use</para>
                <para>
                    <programlisting>$data = ReadFileData::FromMatrix('matrixdata.txt');</programlisting>
                </para>
            </tip>
        </para>
        <para>We will not further discuss all the standard graph formatting options such as the
            ability to add title(s), footers etc. since this is covered in numerous other places in
            this manual.</para>
    </sect1>
    <sect1>
        <title>Mesh interpolating of input data</title>
        <para>By using mesh interpolation it is possible to obtain a "smoother" looking matrix plot
            by creating a "in-between" values in the original matrix by linear interpolation.</para>
        <para>
            <tip>
                <para>This is also used in contour plots. See <xref
                        xlink:href="#sec.grid-interpolating"/> for a more thorough discussion on
                    mesh interpolation and the implication of CPU usage.</para>
            </tip>
        </para>
        <para>The interpolation factor specifies how many times, recursively, the interpolation
            should be done. Practical value ranges from 2-6. While it is possible to specify larger
            values than 6 the time it takes to do the interpolation will grow exponentially in the
            interpolation factor. It is also important to remember that this interpolation dos not
            create any "more" information than what is already available in the matrix. In addition
            it needs to be verified that such a linear interpolation of data is at all valid for the
            underlying data in the matrix. </para>
        <para>As an example the following figures show the effect of doing a 1-5 times interpolation
            of the original data (same as interpolation = 1). With the chosen graph size it is no
            point of interpolating further since doing 5 times interpolating will force the module
            to be 1x1 pixel in order to fit within the constraints of the graph. (The original data
            was 8x11 and interpolating it 5 times creates a 113x161 matrix)</para>
        <informaltable
            frame="none">
            <tgroup
                cols="3">
                <colspec
                    colname="c1"
                    colnum="1"/>
                <colspec
                    colname="c2"
                    colnum="2"/>
                <colspec
                    colname="c3"
                    colnum="3"/>
                <tbody>
                    <row>
                        <entry><inlinemediaobject><imageobject><imagedata
                                        scale="55"
                                        fileref="images/matrix_mesh1.png"/></imageobject></inlinemediaobject></entry>
                        <entry><inlinemediaobject><imageobject><imagedata
                                        scale="55"
                                        fileref="images/matrix_mesh2.png"/></imageobject></inlinemediaobject></entry>
                        <entry><inlinemediaobject><imageobject><imagedata
                                        scale="55"
                                        fileref="images/matrix_mesh3.png"/></imageobject></inlinemediaobject></entry>
                    </row>
                    <row>
                        <entry><inlinemediaobject><imageobject><imagedata
                                        scale="55"
                                        fileref="images/matrix_mesh4.png"/></imageobject></inlinemediaobject></entry>
                        <entry><inlinemediaobject><imageobject><imagedata
                                        scale="55"
                                        fileref="images/matrix_mesh5.png"/></imageobject></inlinemediaobject></entry>
                        <entry/>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>
        <para>The different sizes of the plot is due to the fact that each cell in the matrix must
            have an integer number of pixels. In the graphs above we have used the largest module
            size while still fitting in the image. Hence the different appearances.</para>
        <para>There are two ways of doing this interpolation. </para>
        <para>
            <orderedlist>
                <listitem>
                    <para>When the matrix plot is created by specifying the interpolation factor as
                        the second argument to the plot constructor, i.e.</para>
                    <para>
                        <programlisting>$matrixplot = new MatrixPlot($data,4); // 4 times interpolation</programlisting>
                    </para>
                </listitem>
                <listitem>
                    <para>If many plots share the same data it is more efficient to do it once in
                        the beginning instead of doing the interpolation each time a new matrix plot
                        object is created. This can be done by using the utility function</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>doMeshInterpolate(&amp;$aData, $aFactor)</code></para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>As can be seen from the declaration this is a call by reference method
                        where the data is replaced by the new data that has been interpolated the
                        specified number of times. This avoids unnecessary data copying for large
                        matrices.</para>
                </listitem>
            </orderedlist>
        </para>
        <para>
            <note>
                <para>Those familiar with Matlab (tm) will recognize a similar mesh interpolation in
                    the <code>interp2()</code> function.</para>
            </note>
        </para>
    </sect1>
    <sect1>
        <title>Formatting the matrix plot</title>
        <sect2
            xml:id="sec.matrix-color-maps">
            <title>Color maps</title>
            <para>The color map is a property of the matrix plot and all aspects of the color map is
                accessed through the "<code>MatrixPlot::colormap</code>" property which is an
                instance of <code>class MatrixColormap</code>.</para>
            <para>To adjust how the color map is used the following methods are available</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>ColorMap::SetMap($aMap, $aInvert=false)</code></para>
                        <para>This is a polymorphic method that can take either a symbolic constant
                            as argument and in that case specifies one of the built in color maps or
                            it can be an array of colors which in that case specifies a manual color
                            map. There are several built in color maps of different types which are
                            referenced by an integer in range [0, 19]. A list of the built in color
                            maps can be found in <xref
                                xlink:href="#sec.built-in-colormaps"/></para>
                        <para>For example the specification</para>
                        <para>
                            <programlisting>$mp->colormap->SetMap(0);</programlisting>
                        </para>
                        <para>will make the library use the heat color map which is standard color
                            map that goes from black for the min value up through red, orange,
                            yellow and finally white for the highest value. This could be though of
                            as the color of a heated iron rod (the hottest iron is white
                            glowing).</para>
                        <para>The following manual specification uses three color plateau that the
                            map touches.</para>
                        <para>
                            <programlisting>$map = array( 'navy', 'gray', 'red' );
$mp->colormap->Set($map);</programlisting>
                        </para>
                        <para>would create a color map that would use '<code>navy</code>' color for
                            the min value and '<code>red</code>' for the max value and linearly
                            interpolate all other values for a color range continuously moving from
                                '<code>navy</code>'-'<code>gray</code>'-'<code>red</code>'. The
                            color interpolation made between these values is a linear interpolation
                            of the corresponding RGB values which creates the illusion of a
                            continuous color change. The array must have at least two colors. There
                            is no limit on the maximum number of base colors specified. However
                            using more than ~7-10 colors to specify the color map is probably not to
                            be recommended.</para>
                        <para>If <code>$aInvert</code> is set to <code>true</code> then the color
                            map will be reversed so that the lowest color in the map will be the
                            highest and vice versa.</para>
                    </listitem>
                    <listitem>
                        <para><code>ColorMap::GetCurrMap()</code></para>
                        <para>Return the current set color map</para>
                    </listitem>
                    <listitem>
                        <para><code>ClorMap::SetRange($aMin,$aMax)</code></para>
                        <para>This is used to manually specify the min and max values to be used for
                            mapping matrix values to a color. Any values in the matrix that is lower
                            than <code>$aMin</code> will be set to the min color and any values
                            above <code>$aMax</code> will be set to the maximum color. </para>
                        <para>The matrix values in between will be mapped to the entire color scale.
                            Another way of looking at this is that this will compress the dynamic
                            range used or the colors. If the min and max values specified are much
                            higher and lower than the actual content of the matrix the result is
                            that most of the colors in the matrix will have "middle" colors (and
                            hence lower the contrast). By default the values are (0,0) which means
                            that the library will automatically determine the min/max value based on
                            the input data and use the entire range of colors specified in the color
                            map.</para>
                        <para>
                            <programlisting>&lt;?php
// This will lower the contrast by roughly 50 percent 
$mindataval = ... ; // The minimum data value
$maxdataval = ... ; // The maximum data value
$contrast = -0.5;  // Reduce the contrast by 50%
$adj = ($maxdataval-$mindataval+1)*$contrast/2;
$matrixplot->colormap->SetRange($mindataval+$adj, $maxdataval-$adj);
?></programlisting>
                        </para>
                        <para>In a similar way the following code will instead increase the
                            "contrast" 50% by letting a large part of the data values become mapped
                            to the min and max color values.</para>
                        <para>
                            <programlisting>&lt;?php
// This will increase the contrast by roughly 50 percent 
$mindataval = ... ; // The minimum data value
$maxdataval = ... ; // The maximum data value
$contrast = 0.5;  // Increase the contrast by 50%
$adj = ($maxdataval-$mindataval+1)*$contrast/2;
$matrixplot->colormap->SetRange($mindataval+$adj, $maxdataval-$adj);
?></programlisting>
                        </para>
                        <para>The three plots in <xref
                                xlink:href="#fig.matrix-plot-adj-contrast"/> shows the effect of
                            increasing and decreasing the contrast with this method.</para>
                        <figure
                            xml:id="fig.matrix-plot-adj-contrast">
                            <title>The effects of changing the value range for the colormap</title>
                            <mediaobject>
                                <imageobject><imagedata
                                        scale="50"
                                        fileref="images/matrix-colormap-contrast.png"/></imageobject>
                            </mediaobject>
                        </figure>
                        <tip>
                            <para>When using the auto ranging (the default) the contrast can be
                                adjusted with a call to </para>
                            <para>
                                <itemizedlist>
                                    <listitem>
                                        <para><code>MatrixPlot::SetAutoContrast($aContrast)</code>
                                        </para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                            <para>as in</para>
                            <para>
                                <programlisting>$matrixplot->SetAutoContrast(-0.3);</programlisting>
                            </para>
                        </tip>
                    </listitem>
                    <listitem>
                        <para><code>ColorMap::SetNumColors($aNum)</code></para>
                        <para>This is used to specify the number of discrete color steps used in the
                            map. By default the scale range is divided in approximately 64 color
                            buckets that all matrix entries are mapped into. Depending on the actual
                            color map the specified value might be adjusted up or down up to +/-
                            (p-1). Where <emphasis
                                role="italic">p=number of base colors</emphasis>. Valid ranges are
                            3-128 but is also dependent on the actual color map. </para>
                        <para>The reasons for these restriction and the adjustments are</para>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para>The minimum number of colors are the number of base colors
                                        in the current color map</para>
                                </listitem>
                                <listitem>
                                    <para>The number of colors must satisfy the equation</para>
                                    <para><emphasis
                                            role="italic">n = p + k*(p-1), k = 0, 1, 2,
                                            ...</emphasis> (eq. 1)</para>
                                    <para>where</para>
                                    <para>
                                        <itemizedlist>
                                            <listitem>
                                                <para><emphasis
                                                  role="italic">n</emphasis> = number of
                                                  colors</para>
                                            </listitem>
                                            <listitem>
                                                <para><emphasis
                                                  role="italic">p</emphasis> = number of base colors
                                                  that specifies the map</para>
                                            </listitem>
                                        </itemizedlist>
                                    </para>
                                    <para>The specified number of colors will be adjusted to the
                                        closest number that satisfies (eq. 1). </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                    <listitem>
                        <para><code>ColorMap::SetNullColor($aColor)</code></para>
                        <para>If specified this determines what color will be used for any values in
                            the matrix that are null</para>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
        <sect2>
            <title>Changing the module type (rectangle vs. circle)</title>
            <para>By default the module type (the shape that represents one cell in the matrix) is a
                rectangle. As was mentioned in the introduction this can also be a circle. This is
                controlled by the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixPlot::SetModuleType($aType)</code></para>
                        <para><code>$aType</code>, 0 = Use rectangle, 1 = Use a circle</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>When using circular module type it might also be useful to specify a separate
                background color for the plot since there will be some space between the circles
                where the background can be seen. The plot background is specified with the
                method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixPlot::SetBackgroundColor($aColor)</code></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>An example of using circular modules can be seen in <xref
                    xlink:href="#fig.matrix_ex05"/></para>
            <para>
                <programlisting>#=matrix_ex05|Using a circular module type#</programlisting>
            </para>
        </sect2>
        <sect2>
            <title>Adjusting the alpha blending of the plots</title>
            <para>By default the plots are filled with solid colors from the chosen color map. By
                specifying an alpha value it is possible to let the background shine through the
                matrix plot. The alpha blending is chosen by the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixPlot::SetAlpha($aAlpha)</code></para>
                        <para><code>$aAlpha</code> , 0=No transparency, 1=Full transparency (not so
                            useful since then only the background can be seen)</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <informaltable
                    frame="none">
                    <tgroup
                        cols="2">
                        <colspec
                            colname="c1"
                            colnum="1"/>
                        <colspec
                            colname="c2"
                            colnum="2"/>
                        <tbody>
                            <row>
                                <entry>
                                    <programlisting>#=matrix_ex04.1|Matrix alpha blending=0.2#</programlisting>
                                </entry>
                                <entry>
                                    <programlisting>#=matrix_ex04.2|Matrix alpha blending=0.7#</programlisting>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>
                <note>
                    <para>As can be seen in the figures only the plot area is adjusted. The legend
                        is always shown with no transparency.</para>
                </note>
            </para>
        </sect2>
        <sect2>
            <title>Specifying the size</title>
            <para>There are three and disjunct way to specify the size of the matrix plot. However
                the size can not be set to any pixel value. Since the matrix plot is a visualization
                of a matrix the width and height must always be an even multiple of the number of
                rows and columns since each cell in the matrix have an integer number of pixels as
                width and height (the module size). This will sometimes force the library to adjust
                a specified size so that it is an even multiple of the number of rows and columns in
                the input data matrix.</para>
            <para>For example; if the matrix has 50 columns this means that the width will only grow
                and shrink by multiples of 50 pixels since each cell has an equal number of pixels.
                The minimum width for such a matrix is 50 pixels.</para>
            <para>There are three ways to specify the size:</para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>by setting the width and height explicitly (in number of pixels). </para>
                        <para>Note that the actual rendered size might be different depending on the
                            input matrix size since each cell must have an integer number of pixels
                            and not all sizes will be even dividable with the input data matrix
                            size.</para>
                    </listitem>
                    <listitem>
                        <para>by setting the width and height as fractions of the overall width and
                            height of the graph</para>
                        <para>Note that the actual rendered size might be different depending on the
                            size of the input data matrix.</para>
                    </listitem>
                    <listitem>
                        <para>by specifying the width and height of each rendered cell (a.k.a the
                            module size)</para>
                        <para>This specifies the size (in pixels) of each module. The minimum size
                            is 1x1 pixels.</para>
                    </listitem>
                </orderedlist>
            </para>
            <para>The size is adjusted by the following two methods</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixPlot::SetSize($aW,$aH)</code></para>
                        <para><code>MatrixPlot::SetSize($aW)</code></para>
                        <para>If the two arguments are numbers in range [0.0, 1.0] it will be
                            interpreted as specifying the size as fractions of the overall graph
                            width and height. If the number are > 1 they will be interpreted as the
                            absolute size (in pixels). It is perfectly possible to mix teh two ways.
                            For example the following is a valid size specification</para>
                        <para>
                            <programlisting>$matrixplot->SetSize(250,0.6); // 250px wide and height will be ~60% of the graph height</programlisting>
                        </para>
                        <para>If only one argument is specified it will set both the width and
                            height to the specified size. If the single size is specified as a
                            fraction the smallest of the graph width/height will be used as the
                            base.</para>
                    </listitem>
                    <listitem>
                        <para><code>MatrixPlot::SetModuleSize($aW,$aH)</code></para>
                        <para>The two argument specifies the module size, i.e. the size of each cell
                            in the plot (in pixels).</para>
                    </listitem>
                </itemizedlist>
                <note>
                    <para>The size does not effect the legend that belongs to a matrix plot.</para>
                </note>
            </para>
        </sect2>
        <sect2>
            <title>Specifying the position of the plot on the graph</title>
            <para>The position of the plot by is by default centered vertically and slightly move to
                the left of the vertical center in order to compensate for the default legend that
                is shown n the right of the plot. The position of the plot is specified by the
                method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixPlot::SetCenterPos($aX,$aY)</code></para>
                        <para>Specifies the center of the plot to be the given x and y-coordinates.
                            The position can be specified in either absolute pixels or as fractions
                            of the width and height (or as a combination).</para>
                    </listitem>
                </itemizedlist>
                <tip>
                    <para>In order to position multiple plots on the same graph it is easier to user
                        the layout classes (as described in <xref
                            xlink:href="#sec.matrix-layout-classes"/>)</para>
                </tip>
            </para>
        </sect2>
        <sect2>
            <title>Adjusting the legend</title>
            <para>The legend belongs to the matrix plot and not the graph. All legend are instances
                of <code>class MatrixLegend</code> and is accessed through the property</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixPlot::legend</code></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>By default the legend is enabled and positioned to the right of the plot. Both the
                size and position of the legend can be manually adjusted. </para>
            <para>There are four possible positions of the legend as shown in <xref
                    xlink:href="#fig.matrix-legend-pos"/>, on each of the four sides of the plot.
                The labels of the legend will be automatically adjusted to face aways from the
                plot.</para>
            <figure
                xml:id="fig.matrix-legend-pos">
                <title>Matrix legend positions</title>
                <mediaobject>
                    <imageobject><imagedata
                            fileref="images/matrix_legend_pos.png"
                            scale="60"/></imageobject>
                </mediaobject>
            </figure>
            <para>To position the legend the following <code>MatrixPlot</code> method is used</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixPlot::SetLegendLayout($aPos)</code></para>
                        <para>The position of the legend is specified as an integer in range [0-3]
                            where 0 is the right side of the plot and the remaining posiotins follow
                            clockwise from the right, (i.e. 1 is the bottom, 2 is the left and 3 is
                            the top side).</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>The following methods can be used to fine tune and adjust the legend</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixLegend::Show($aFlg=true)</code></para>
                        <para>Used to enable/disable the legend. The following code line would hide
                            the legend</para>
                        <para>
                            <programlisting>$matrixplot->legend->Show(false);</programlisting>
                        </para>
                    </listitem>
                    <listitem>
                        <para><code>MatrixLegend::SetModuleSize($aBucketWidth,$aBucketHeight=5)</code></para>
                        <para>This specifies the size of each color bucket in the legend. </para>
                    </listitem>
                    <listitem>
                        <para><code>MatrixLegend::SetSize($aWidth,$aHeight=5)</code></para>
                        <para>This is an alternative way to specify the size of the legend compare
                            with the individual bucket specification. With this method the overall
                            width and height of the legend bar can be adjusted. The size can be
                            specified s either absolute pixels or as fraction of the width height of
                            the entire graph.</para>
                    </listitem>
                    <listitem>
                        <para><code>MatrixLegend::SetMargin($aMargin)</code></para>
                        <para>Specifies the margin (in pixels) between the matrix plot and the
                            legend.</para>
                    </listitem>
                    <listitem>
                        <para><code>MatrixLegend::SetLabelMargin($aMargin)</code></para>
                        <para>Specifies the margin between the min/max label and the legend
                            bar</para>
                    </listitem>
                    <listitem>
                        <para><code>MatrixLegend::SetFont($aFamily,$aStyle,$aSize)</code></para>
                        <para>Specifies the font for the label on the legend</para>
                    </listitem>
                    <listitem>
                        <para><code>MatrixLegend::SetFormatString($aStr)</code></para>
                        <para>Specifies the format string (in <code>printf()</code> format) to be
                            used when rendering the legend label</para>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
        <sect2>
            <title>Adding row and column legends</title>
            <para>
                <note>
                    <para>This feature is only available in v3.0.4p and above.</para>
                </note>
            </para>
            <para>When using matrix plots to display micro arrays it is often desirable to have
                legends for each row and column. <xref
                    xlink:href="#fig.matrix_edgeex01"/> shows an example of this which helps
                understand this concept.</para>
            <para>
                <programlisting>#=matrix_edgeex01|Adding row and column legends to a matrix plot#</programlisting>
            </para>
            <para>In the library this is modelled by the <code>class EdgeLabel</code> which is
                instantiated in the matrix plot as</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>MatrixPlot::collabel</code></para>
                        <para>Instance for horizontal labels</para>
                    </listitem>
                    <listitem>
                        <para><code>MatrixPlot::rowlabel</code></para>
                        <para>Instance for vertical labels</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>To adjust the appearance of the labels the following methods can be used:</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><emphasis
                                role="bold"><code>EdgeLabel::SetFont($aFF,$aFS,$aSize)</code></emphasis></para>
                        <para>Specify the font to be used. Keep in mind that the font size should
                            not be larger than the module size chosen to be able to fit within the
                            row/column it specifies. For the default module size a font size of 8-9
                            for a TTF font is usually fine. By default the labels are set in
                            FF_ARIAL, 8 pt size.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis
                                role="bold"><code>EdgeLabel::SetFontColor($aColor)</code></emphasis></para>
                        <para>Specifies the font color.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis
                                role="bold"><code>EdgeLabel::SetMargin($aMargin)</code></emphasis></para>
                        <para>Set the margin from the edge of the matrix in pixels.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis
                                role="bold"><code>EdgeLabel::SetSide($aSide)</code></emphasis></para>
                        <para>Specifies on what side the labels should be drawn. For horizontal (x)
                            labels the possible sides are <code>"left"</code> or
                                <code>"right"</code> and for vertical (y) the possible sides are
                                <code>"top"</code> and <code>"bottom"</code>.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis
                                role="bold"><code>EdgeLabel::Set($aLabels)</code></emphasis></para>
                        <para>Specifies the 1-dimensional array that holds the labels to be
                            used.</para>
                    </listitem>
                    <listitem>
                        <para><emphasis
                                role="bold"><code>EdgeLabel::SetAngle($aAngle)</code></emphasis></para>
                        <para>Specify the angle to draw the label at. By default row labels are
                            drawn at 0 degree and column labels are drawn at 90 degrees
                            angle.</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>The simplest use of labels is to use the default values for all parameters and
                just set the labels, i.e.</para>
            <para>
                <programlisting>&lt;?php
$data = array( ... ) ;
$collabels = array( ... ) ;
$rowlabels = array( ... ) ;

$mp = new MatrixPlot($data);

$mp->collabel->Set($collabels);
$mp->rowlabel->Set($rowlabels);
?></programlisting>
            </para>
            <para>Below is a final example of adding row and column labels to a matrix graph</para>
            <para>
                <programlisting>#=matrix_edgeex02|Adding row and column legends to a matrix plot##</programlisting>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Adding icon and text objects to the graph</title>
        <para>Matrix plots supports the ordinary way of adding icon and text objects to the graph. </para>
        <sect2>
            <title>Adding a text object</title>
            <para>Text objects are added by first creating an instance of <code>class Text</code>
                for each text needed and then adding the text to the graph with the usual call to
                    <code>MatrixGraph::Add()</code>. </para>
            <para>A basic text will only require two additional lines of code</para>
            <para>
                <programlisting>&lt;?php
$txt = new Text('Simple string',20,20);
$graph->Add($txt); 
?></programlisting>
            </para>
            <para>The following code snippet is slightly more complicated and will create a boxed
                text in the upper right corner of the graph. </para>
            <para>
                <programlisting>&lt;?php
// Add a boxed text
$txt = new Text();
$txt->SetFont(FF_ARIAL,FS_NORMAL,10);
$txt->Set("Arbitrary text\non a\nMatrix Plot");
$txt->SetParagraphAlign('center');
$txt->SetPos(0.95,0.15,'right');
$txt->SetBox('lightyellow');
$txt->SetShadow();
$graph->Add($txt); 
?></programlisting>
            </para>
            <para>The snippet above adds a text at coordinates X=20, Y=20 using the default lower
                left corner as the text anchor point.</para>
            <para>
                <note>
                    <para>To add a newline you must remember to use double-quotes to enclose the
                        text otherwise the "\n" will only be interpreted literally. </para>
                </note>
            </para>
            <para>
                <note>
                    <para>Remember that the "text align", as adjusted with <code>SetAlign()</code>,
                        specifies the anchor point for the text, i.e. what part of the text is
                        aligned with the specified position. </para>
                </note>
            </para>
            <para>To add many text strings it is often useful to specify them in an array and then
                have a loop creating the text object and add the text array of all the created
                objects to the graph as the following short snippet shows.</para>
            <para>
                <programlisting>&lt;?php
//--------------------------------------------------------------
// Add texts to the graph
//--------------------------------------------------------------
$txts = array( 
    array('Textstring one ...',$tx1,$ty1),
    array('Textstring two ...',$tx2,$ty2),
    array('Textstring three ...',$tx3,$ty3),

$n=count($txts);
$t=array();
for($i=0; $i &lt; $n; ++$i){
    $t[$i] = new Text($txts[$i][0],$txts[$i][1],$txts[$i][2]);
    $t[$i]->SetFont(FF_ARIAL,FS_NORMAL,12);
    $t[$i]->SetColor('brown');
    $t[$i]->SetAlign('center','top');
}
$graph->Add($t);
?></programlisting>
            </para>
        </sect2>
        <sect2>
            <title>Adding icons to the graph</title>
            <para>Icons are added as instances of <code>class IconPlot</code> to the graph (as usual
                with a call to <code>MatrixGraph::Add()</code>). This means that to use icons the
                library module "<filename>jpgraph_iconplot.php</filename>" must first be included. </para>
            <para>The following example shows how to add a small icon in the lower right corner of
                the graph. For more information on formatting icons that are added to a graph see <xref
                    xlink:href="#sec.adding-icons-to-graph"/></para>
            <para>
                <caution>
                    <para>Since Matrix graphs doesn't have a ny concept of linear scale the position
                        of icons can only be specified as absolute pixels or as fractions of the
                        width/height.</para>
                </caution>
            </para>
            <para>
                <programlisting>#matrix_ex03|Adding an icon to the lower right corner#</programlisting>
            </para>
            <para>We also recall that it is possible to use country flags as icons by making use of
                the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>IconPlot::SetCountryFlag($aFlag,$aX=0,$aY=0,$aScale=1.0,$aMix=100,$aStdSize=3)</code></para>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
        <sect2>
            <title>Adding background images</title>
            <para>In just the same way as for all other plots it is possible to add a background
                images, background gradients and a background flag to the graph. Since this has been
                discussed several time previously in the manual we only show a simple example
                here.</para>
            <para>
                <note>
                    <para>Since Matrix graphs does not have the concept of plot area the background
                        image positioning alternative <code>BGIMG_FILLPLOT</code> is the same as
                            <code>BGIMG_FILLFRAME</code> as we have used in this example
                        below.</para>
                </note>
            </para>
            <para>
                <programlisting>#matrix_ex04|Adding a background image to the matrix graph#</programlisting>
            </para>
        </sect2>
    </sect1>
    <sect1>
        <title>Adding marker lines to the matrix plot</title>
        <para>
            <note>
                <para>This feature was added in 3.1.1p</para>
            </note>
        </para>
        <para>In order to mark important divisions in the plot it is possible to add an instance of
                <code>class PlotLine</code> (either horizontal or vertical line) to each plot in the
            graph. For example, to add one vertical and one horizontal plot line the following lines
            can be added to the matrix script</para>
        <para>
            <programlisting>&lt;?php
$mp = new MatrixPlot($data);

// Create two lines to add as markers
$l1 = new PlotLine(VERTICAL, 5, 'lightgray:1.5', 4);
$l2 = new PlotLine(HORIZONTAL, 3, 'lightgray:1.5', 4);

// Add lines to the plot
$mp->AddLine($l1);
$mp->AddLine($l2);
// this could also be done as
// $mp->AddLine(array($l1,$l2));

...
?></programlisting>
        </para>
        <para>The example in <xref
                xlink:href="#fig.matrix_ex06"/> shows an example of this</para>
        <para>
            <programlisting>#=matrix_ex06|Adding plot lines to the matrix plot#</programlisting>
        </para>
    </sect1>
    <sect1
        xml:id="sec.matrix-layout-classes">
        <title>Using layout classes to position matrix plots</title>
        <para>Normally we don't want to have to calculate the absolute x and y coordinates when
            positioning multiple Matrix plots in graph. A much better concept would be to just tell
            the library to position three matrix plots horizontally or vertically without having to
            figure out the exact coordinates our self but just evenly distribute them in the
            specified direction.</para>
        <para>This is where layout classes come in handy.</para>
        <para>There are two types of layouts; horizontal and vertical. To specify that two matrix
            plots should be positioned side by side (horizontal) a new horizontal layout object is
            created and then the two matrix plots are added as object within the horizontal layout
            class. Later on when the objects are about to be stroked on the graph the horizontal
            layout class will take all its objects and spread them out evenly along a horizontal
            line depending on the individual size of each matrix plot (including the specified
            margin). The same principle applies to the vertical layout class with the obvious change
            in direction.</para>
        <para>The layout object are added to the graph in exactly the same way as ordinary matrix
            plots, by calling the <code>MatrixGraph::Add()</code> method. </para>
        <para>The following line would create a horizontal line of three matrix plots</para>
        <para>
            <programlisting>&lt;?php
$graph = new MatrixGraph($width,$height);

// additional graph formatting

$mp1 = new MatrixPlot($mat1);
$mp2 = new MatrixPlot($mat1);
$mp3 = new MatrixPlot($mat1);

$hor = new LayoutHor( array( $mp1, $mp2, $mp3) );

$graph->Add($hor);
$graph->Stroke();
?></programlisting>
        </para>
        <para>A complete example of this can be seen in <xref
                xlink:href="#fig.matrix_layout_ex1"/></para>
        <para>
            <programlisting>#matrix_layout_ex1|Using layout classes with Matrix plots#</programlisting>
        </para>
        <para>When using layout classes there is one parameter of the matrix plot that can be
            adjusted and that is the margin around each matrix plot. This margin is controlled by a
            call to</para>
        <para>
            <itemizedlist>
                <listitem>
                    <para>
                        <code>MatrixPlot::SetMargin($aMargin)</code>
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>By default the margin is 20 pixels on each side. This margin also takes the legend
            into consideration so the margin is counted from the edge of the legend.</para>
    </sect1>
    <sect1
        xml:id="sec.built-in-colormaps">
        <title>Built in color maps</title>
        <para>There are three types of built in color maps</para>
        <para>
            <orderedlist>
                <listitem>
                    <para><emphasis
                            role="bold">Standard maps</emphasis></para>
                    <para>Includes rainbow spectrum and heat maps and combination of plain
                        red-green-blue maps</para>
                </listitem>
                <listitem>
                    <para><emphasis
                            role="bold">Normalized center</emphasis></para>
                    <para>These maps have a white:ish center. This is mostly useful to visualize the
                        spread from a center value</para>
                </listitem>
                <listitem>
                    <para><emphasis
                            role="bold">Continues</emphasis></para>
                    <para>The maps have one base color where the hue changes</para>
                </listitem>
            </orderedlist>
        </para>
        <para>In the color maps in the following section the black bars under some colors in the
            color map shows the discrete colors (the plateaus) that the color map is made up of. All
            colors in between two "barred" colors are linear interpolations.</para>
        <para>The script that was used to generate these color maps can be found under the example
            directory as "<filename>colormaps.php</filename>".</para>
        <sect2>
            <title>Standard maps</title>
            <para>To show heat gradient map 0 is the standard color map. To highlight the min and
                max values (to get a high contrast) map 3 is a good choice. Map two is a standard
                "rainbow" spectrum from red all up to violet.</para>
            <figure>
                <title>Standard color maps</title>
                <mediaobject>
                    <imageobject><imagedata
                            fileref="images/colormap_standard.png"
                            scale="50"/></imageobject>
                </mediaobject>
            </figure>
        </sect2>
        <sect2>
            <title>Normalized center</title>
            <para>These maps have a neutral (white) center and feathers out to the min/max value at
                each end.</para>
            <figure>
                <title>Centered color map</title>
                <mediaobject>
                    <imageobject><imagedata
                            fileref="images/colormap_center.png"
                            scale="50"/></imageobject>
                </mediaobject>
            </figure>
        </sect2>
        <sect2>
            <title>Continues map</title>
            <para>These maps changes continues from the min color to the max color.</para>
            <figure>
                <title>Continues color map</title>
                <mediaobject>
                    <imageobject><imagedata
                            fileref="images/colormap_continues.png"
                            scale="50"/></imageobject>
                </mediaobject>
            </figure>
        </sect2>
    </sect1>
    <sect1>
        <title>Using CSIM with matrix plots</title>
        <para>
            <note>
                <para>This feature was added in v3.1.1p</para>
            </note>
        </para>
        <para>In the same was as most other plot types matrix plots also supports the usage of
            Client Side Image Maps. (See <xref
                xlink:href="#chap.using-csim"/> for a full description on the usage of CSIM in
            general the library.)</para>
        <para>The possible hotspot areas in a matrix graph are:</para>
        <para>
            <itemizedlist>
                <listitem>
                    <para>The title</para>
                    <para>This is set (as usual with a call to)
                            <code>MatrixGraph::title::SetCSIM()</code></para>
                </listitem>
                <listitem>
                    <para>Each cell in the matrix itself.</para>
                    <para>This is set with a call to <code>MatrixPlot::SetCSIM()</code> The input is
                        specified with a matrix of the same size as the input data. An error message
                        will be given if the sizes differ.</para>
                </listitem>
                <listitem>
                    <para>Each row and column label text. The input must be an array of the same
                        length as the number of labels.</para>
                    <para>This is specified with either (or both)</para>
                    <para><code>MatrixGraph::rowlabel::SetCSIM()</code></para>
                    <para><code>MatrixGraph::collabel::SetCSIM()</code></para>
                </listitem>
            </itemizedlist>
        </para>
        <para>The following example shows how to add both label and data CSIM. As usual the graph
            must be stroked with a call to <code>MatrixGraph::StrokeCSIM()</code> when using CSIM
            functionality. </para>
        <para>
            <programlisting>#:matrix_csimex01|Matrix example with CSIM#</programlisting>
        </para>
    </sect1>
    <sect1>
        <title>Matrix graph examples</title>
        <sect2>
            <title>Example 1</title>
            <para/>
        </sect2>
        <sect2>
            <title>Example 2</title>
            <para/>
        </sect2>
        <sect2>
            <title>Example 3</title>
            <para/>
        </sect2>
        <sect2>
            <title>Example 4</title>
            <para/>
        </sect2>
    </sect1>
</chapter>
