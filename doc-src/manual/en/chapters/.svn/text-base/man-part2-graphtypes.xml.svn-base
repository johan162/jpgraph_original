<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<part version="5.0" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Creating linear and non-linear graphs</title>
    <chapter>
        <title>Different types of linear (cartesian) graph types</title>
        <para>
            <figure>
                <title>Supported linear graph types in the library</title>
                <informaltable frame="none">
                    <tgroup cols="3">
                        <colspec colname="c1" colnum="1"/>
                        <colspec colname="c2" colnum="2"/>
                        <colspec colname="c3" colnum="3"/>
                        <tbody>
                            <row>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata
                                                  fileref="images/ploticon_line.png" scale="60"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>a) Line plot</para>
                                    <para>(See <xref xlink:href="#sec2.creating-line-graph"
                                        />)</para>
                                </entry>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_area.png"
                                            /></imageobject></inlinemediaobject></para>
                                    <para>b) Area plot</para>
                                    <para>(See <xref xlink:href="#sec2.creating-area-graph"
                                        />)</para>
                                </entry>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_bar.png"
                                            /></imageobject></inlinemediaobject></para>
                                    <para>c) Bar plot</para>
                                    <para>(See <xref xlink:href="#sec1.creating-bar-graphs"
                                        />)</para>
                                </entry>
                            </row>
                            <row>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_field.png"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>a) Field plot</para>
                                    <para>(See <xref xlink:href="#sec1.creating-field-graphs"
                                        />)</para>
                                </entry>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_error.png"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>b) Error plot</para>
                                    <para>(See <xref xlink:href="#sec1.creating-error-graphs"
                                        />)</para>
                                </entry>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_stock.png"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>c) Stock plot</para>
                                    <para>(See <xref xlink:href="#sec1.creating-stock-graphs"
                                        />)</para>
                                </entry>
                            </row>
                            <row>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_geomap.jpg"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>a) Geo-map plot</para>
                                    <para>(See <xref xlink:href="#sec1.creating-geo-maps"/>)</para>
                                </entry>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_impuls.png"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>b) Impuls (stem) plot</para>
                                    <para>(See <xref xlink:href="#sec1.creating-scatter-graphs"
                                        />)</para>
                                </entry>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_spline.png"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>c) Spline plot</para>
                                    <para xlink:href="#sec2.creating-cubic-splines">(See <xref
                                            xlink:href="#sec2.creating-cubic-splines"/>)</para>
                                </entry>
                            </row>
                            <row>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_balloon.png"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>a) Balloon plot</para>
                                    <para>(See <xref xlink:href="#sec1.creating-balloon-graphs"
                                        />)</para>
                                </entry>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_scatter.png"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>b) Scatter plot</para>
                                    <para>(See <xref xlink:href="#sec1.creating-scatter-graphs"
                                        />)</para>
                                </entry>
                                <entry align="center">
                                    <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_contour.png"
                                                /></imageobject></inlinemediaobject></para>
                                    <para>c) Contour plot</para>
                                    <para>(See <xref xlink:href="#sec.contour-graphs"/>)</para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </figure>
        </para>
        <sect1>
            <title>Basic Line and area graphs</title>
            <para>Line graphs (we will use the term line graph to refer to an entire graph and the
                term line plot to refer to a single data series in a line graph) is together with
                bar graphs the simplest and perhaps the most commonly used graph type. In <xref
                    xlink:href="#sec1.graphing-sun-spots"/> we have already shown an example of a
                line graph without explaining to much of the details. The remainder of the section
                will go into some more details on the options available when creating a line
                graph.</para>
            <sect2 xml:id="sec2.creating-line-graph">
                <title>Creating a line graph</title>
                <para>A line graph always make use of one or several instances of the <code>class
                        LinePlot</code> which represent one plotted data series in the graph. In all
                    our example we follow the naming convention to always name the instance of the
                    LinePlot class as "<code>$lineplot</code>"</para>
                <para>The absolutely simplest line graph that is possible to create is shown in
                        <xref xlink:href="#fig.example0-0"/></para>
                <para>
                    <programlisting>#example0-0|The most simple line graph#</programlisting>
                </para>
                <para>There are a number of things to point out here</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>Both the X and Y axis have been automatically scaled and since we
                                didn't provide any x-scale the data point have been numbered
                                automatically starting at 0</para>
                        </listitem>
                        <listitem>
                            <para>By default the Y-grid is enabled and displayed in a "soft"
                                color</para>
                        </listitem>
                        <listitem>
                            <para>By default the overall graph has a black bordered and a light gray
                                margin</para>
                        </listitem>
                        <listitem>
                            <para>By default the size of the margin around the plot area is
                                automatically calculated</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>While the above example is a perfectly fine graph it looks a bit poor and we
                    could probably make use of a graph title as well as titles on the axis to
                    explain the units we are working with. So lets change the simple graph in <xref
                        xlink:href="#fig.example0-0"/> by adding a few lines to set some titles and
                    get the modified graph shown in <xref xlink:href="#fig.example2"/></para>
                <para>
                    <programlisting>#example2|Adding some titles#</programlisting>
                </para>
                <para>Worth noting in this example are</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>The main graph class instance ($graph) is used as the base to
                                access most properties of the overall graph</para>
                        </listitem>
                        <listitem>
                            <para>The margins have been slightly increased to account for the titles
                                of the axis</para>
                        </listitem>
                        <listitem>
                            <para>The default position for the title of the x-axis is on the far
                                right and for the y-axis it is placed centered in the middle and
                                rotated in a 90 angle (vertical).</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>A nice change would now be to have the titles of the axis in a bold font and
                    the line plot a little bit thicker and in blue color. Let's do that by adding
                    the lines</para>
                <para>
                    <programlisting>&lt;?php
$graph -> title -> SetFont ( FF_FONT1 , FS_BOLD );
$graph -> yaxis -> title -> SetFont ( FF_FONT1 , FS_BOLD );
$graph -> xaxis -> title -> SetFont ( FF_FONT1 , FS_BOLD );
$lineplot -> SetColor ( 'blue' );
$lineplot -> SetWeight ( 2 );   // Two pixel wide 
?></programlisting>
                </para>
                <para>As was explained in <xref xlink:href="#chap.text_handling"/> this will adjust
                    the fonts of the titles to make use of a bold variant of the built-in bitmap
                    fonts. Please note the consistent naming conventions used in the library. Most
                    objects support a common set of basic methods to adjust font, size and colors
                    wherever such concepts make sense.</para>
                <para>The result of adding these lines are shown in <xref xlink:href="#fig.example3"
                    /> (click on the link in the title to see the full source).</para>
                <para>
                    <programlisting>#=example3|Changing fonts of the axis titles and adjusting plot weight#</programlisting>
                </para>
                <para>As a final touch lets make the y-axis have the same color as the data series
                    to stronger show the connection between the data and the scale. At the same time
                    we take the opportunity to add a drop shadow to the overall graph. We do both of
                    these things by adding the following two lines at appropriate places in the
                    script</para>
                <para>
                    <programlisting>&lt;?php
$graph->SetShadow();
$graph->yaxis->SetColor('blue');
?></programlisting>
                </para>
                <para>The results is shown in <xref xlink:href="#fig.example3.0.1"/> below</para>
                <para>
                    <programlisting>#=example3.0.1|Adding drop shadow and changing axis color#</programlisting>
                </para>
                <para>
                    <tip>
                        <para>Remember that the library has multiple ways to handle null data values
                            as described in <xref xlink:href="#sec1.null-value-handling"/></para>
                    </tip>
                </para>
            </sect2>
            <sect2>
                <title>Automatic interpolation of unknown data</title>
                <para>Line graphs supports automatic linear interpolation of missing data point if
                    the missing data point is replaced by a '-' (hyphen character) for more on
                    handling of NULLs in the input data see <xref
                        xlink:href="#sec1.null-value-handling"/>. </para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=example3.0.3|Original null values#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=example3.0.2|Using '-' to get interpolated lines#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para>There is one option to control the behavior of the interpolation together with
                    accumulated line plots and that is how to handle the case where the initial or
                    ending data are unknown.</para>
                <para>For accumulated line plots (see below) this is especially critical since each
                    value is plotted with an offset of the "previous" plot and hence all values must
                    be known. By default if the first data value is unknown it will be set to the
                    same value as the first found non-null value. It is also possible, for
                    accumulated line plots, to force the first and last unknown value to be equal to
                    0 (zero). This is controlled by the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>AccLinePlot::SetInterpolateMode($aForceZero)</code></para>
                            <para>A value of true for the for the argument will force any first or
                                last unknown values to be interpreted as 0 for an accumulated line
                                plot.</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect2>
            <sect2 xml:id="sec.adding-marks">
                <title>Adding marks to the plot (a.k.a. plot marks)</title>
                <para>Another common embellishment of plots is to add markers for each data point.
                    The library supports a large number of built-in plot marks as well as the
                    ability to use arbitrary images as plot marks. Plot marks are instantiated as an
                    instance of <code>class PlotMark</code> defined in the module
                        "<filename>jpgraph:plotmark.inc.php</filename>"</para>
                <para>There are three types of built-in plot marks</para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para><emphasis role="bold">Line based. </emphasis></para>
                            <para>These marks are drawn directly by the library at the appropriate
                                places in the graph. These marks are simple rectangles, squares,
                                stars etc The size and colors (both edge and fill) are user
                                adjustable.</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Image based symbols. </emphasis></para>
                            <para>These marks look much more "refined" and are actually small
                                built-in images that are scaled and placed (copied) to the
                                appropriate position in the graph. Since these are predefined images
                                they are only available in a certain number of colors and shapes.
                            </para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Country flags</emphasis></para>
                            <para>As was previously discussed the library supports (as of Dec 2008)
                                all known countries and it is possible to use the country flags both
                                as background in the graphs as well as plot marks.</para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>A full list of all available built-in plot marks and there symbolic names are
                    given in <xref xlink:href="#app.plotmark-list"/>.</para>
                <para>For now lets keep things simple and just add a small triangle at each of the
                    specified data points by adding the lines</para>
                <para>
                    <programlisting>&lt;?php
$lineplot->mark->SetType(MARK_UTRIANGLE);
$lineplot->mark->SetColor('blue');
$lineplot->mark->SetFillColor('red');
?></programlisting>
                </para>
                <para>
                    <caution>
                        <para>The colors of the marks will, if you don't specify them explicitly,
                            follow the line color. Please note that if you want different colors for
                            the marks and the line the call to <code>SetColor()</code> for the marks
                            must be done after the call to the <code>SetColor()</code> for the line
                            since the marks color will always be reset to the lines color when you
                            set the line color.</para>
                    </caution>
                </para>
                <para>The result after making these modifications are shown in <xref
                        xlink:href="#fig.example3.1"/></para>
                <para>
                    <programlisting>#=example3.1|Adding basic plot marks to the plot#</programlisting>
                </para>
                <para>
                    <tip>
                        <para>In addition to the built in plot marks it is also possible to use a
                            user specified image as a plot mark. See <xref
                                xlink:href="#fig.footerex1"/> for an example of how to use this
                            feature. To use this feature the plot mark type is specified as
                                <code>MARK_IMG</code> and the file name of the image is given. For
                            example the following line will us the image file "myimage.jpg" as plot
                            marks and scale the image to 50% of its original size</para>
                        <para>
                            <programlisting>$lineplot->mark->SetType(MARK_IMG,'myimage.jpg','0.5');</programlisting>
                        </para>
                    </tip>
                </para>
                <para>As a final example we show an example of using one of the built-in image marks
                    by adding the line</para>
                <para>
                    <programlisting>$lineplot->mark->SetType(MARK_IMG_DIAMOND,'red',0.5);</programlisting>
                </para>
                <para>This will add a red diamond mark scaled to 50% of its original size to better
                    fit the overall size of the graph. The result of adding this is shown in <xref
                        xlink:href="#fig.example3.1.1"/></para>
                <para>
                    <programlisting>#=example3.1.1|Using one of the built-in images as plot mark, MARK_IMG_DIAMOND#</programlisting>
                </para>
                <para>
                    <tip>
                        <para>Note that some of the built in images are available in different
                            sizes. The reason is that even though it is possible to n scale them by
                            the third argument there is a visual degradation to scale an image
                            larger than it's original size since some pixels needs to be
                            interpolated. Reducing the size with a scale &lt; 1.0 gives much better
                            visual appearance.</para>
                    </tip>
                </para>
                <para>In order to use one of the available country flags the type is specified as
                        <code>MARK_FLAG1</code>, <code>MARK_FLAG2</code>, <code>MARK_FLAG3</code> or
                        <code>MARK_FLAG4</code> which represent the native size of the flag (in
                    increasing order). The second argument to <code>SetType()</code> is either the
                    ordinal index number of the country flag or its short name (as listed <xref
                        xlink:href="#app.country-flags"/>). The following example illustrates both
                    these methods of specifying the country flags. The two critical lines are</para>
                <para>
                    <programlisting>&lt;?php
$p1->mark->SetType(MARK_FLAG1,197);
$p2->mark->SetType(MARK_FLAG1,'united states');
?></programlisting>
                </para>
                <para>and the result of creating a graph with some data using country flags as data
                    markers are shown in <xref xlink:href="#fig.markflagex1"/></para>
                <para>
                    <programlisting>#=markflagex1|Using country flags as plot marks#</programlisting>
                </para>
                <para>In addition the plot mark formatting shown above plot marks also supports
                    formating through the use of a callback function. The callback function will be
                    passed the y-value as its only argument and the callback function must return an
                    array consisting of three value, weight, color and fill-color. This could be
                    used to for example alter the colors of the plot marks depending on the actual
                    value. A common use of this feature is to create "balloon" scatter plot where a
                    variable sized filled circle is positioned at specific data points. This is a
                    way t create a 2D plot which conveys three values at each data point, x,y and
                    size. In the section on Scatter plot (see <xref
                        xlink:href="#sec1.creating-scatter-graphs"/>) we show an example of
                    this.</para>
            </sect2>
            <sect2>
                <title>Displaying the values at the data points</title>
                <para>Lets continue the previous example by making some minor adjustments to also
                    show the values at each data point. The data label at each data point is
                    represented by the instance variable "$value". This is an instance of the
                        <code>class DisplayValue</code> and all normal text attributes can be
                    adjusted (e.g. color, size, fonts etc). The value is applied to all
                    labels.</para>
                <para>In addition to the usual text formatting it is also possible to adjust how the
                    numeric data labels is formatted. This is done by one of two ways.</para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>by submitting a suitable format string. This format string follows
                                the same syntax as the <code>printf()</code> format string.</para>
                        </listitem>
                        <listitem>
                            <para>by specifying a format callback function. This callback function
                                must take exactly one argument (which is the data value) and return
                                the wanted string that should be displayed.</para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>In order to display the values the first thing that must happen is to enable
                    the values. This is done by a call to </para>
                <para>
                    <programlisting>$lineplot->value->Show();</programlisting>
                </para>
                <para>The result of adding this line is shown in <xref xlink:href="#fig.example3.3"
                    /></para>
                <para>
                    <programlisting>#=example3.3#</programlisting>
                </para>
                <para>We can now modify the appearance of the labels by changing the font and
                    changing the way the labels are formatted. We do this by adding the following
                    lines to the previous example</para>
                <para>
                    <programlisting>&lt;?php
$lineplot->value->SetFont(FF_ARIAL,FS_BOLD,10);
$lineplot->value->SetColor('darkred');
$lineplot->value->SetFormat('(%d)');
?></programlisting>
                </para>
                <para>The resulting graph can be seen in <xref xlink:href="#fig.example3.4"/></para>
                <para>
                    <programlisting>#=example3.4|Changing the appearance of data labels#</programlisting>
                </para>
                <para>
                    <tip>
                        <para>To get 1000' separators use the PHP function number_format() as a
                            callback function</para>
                    </tip>
                </para>
                <para>
                    <tip>
                        <para>To use method in classes as callback the callback method has to be
                            specified as an array with two string entries. The first entry must be
                            the class and the second entry must be the method name. Note that
                            callback method should be static as no instance context can be
                            created.</para>
                    </tip>
                </para>
                <para>As a final example we make use of a callback function to format the values as
                        <emphasis role="italic">Roman Numerals</emphasis> . The result of this can
                    be seen in <xref xlink:href="#fig.example3.4.1"/></para>
                <para>
                    <programlisting>#=example3.4.1|Formatting display values as roman numerals#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Adding several data series to the same graph</title>
                <para>Up to now all examples we have shown have only had one data series. As was
                    mentioned in the introduction a graph can have an unlimited number of data
                    series (plots) although from a practical consideration (and "viewability") it is
                    probably best to restrict the number of data series in one graph to less than
                    5-6.</para>
                <para>The steps to do this is exactly a repetition of what the examples have shown
                    up to now. The only thing that is needed is to create the second data series, by
                    creating a new instance of a the LinePlot class, set the attributes, and finally
                    add it to the graph.</para>
                <para>The following lines show how to create the new data series/plot and add it to
                    the graph (we only show the new lines - not the full script)</para>
                <para>
                    <programlisting>&lt;?php
$ydata2  = array( 1 , 19 , 15 , 7 , 22 , 14 , 5 , 9 , 21 , 13 );

// Create a new data series with a different color
$lineplot2 = new  LinePlot ( $ydata2 );
$lineplot2->SetWeight ( 2 );

// Also add the new data series to the graph
$graph->Add( $lineplot2 );</programlisting>
                </para>
                <para>Making these additions will create the graph in <xref
                        xlink:href="#fig.example4"/></para>
                <para>
                    <programlisting>#=example4|Adding a second data series#</programlisting>
                </para>
                <para>There are two things to note here</para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>The Y-scale has changed to accommodate the larger range of
                                Y-values for the second graph.</para>
                        </listitem>
                        <listitem>
                            <para>The colors for each successive data series is allocated
                                automatically but of course it is also possible to set the color
                                manually.</para>
                        </listitem>
                        <listitem>
                            <para>If you add several plots to the same graph they should contain the
                                same number of data points. This is not a requirement (the graph
                                will be automatically scaled to accommodate the plot with the
                                largest number of points) but it will not look very good since one
                                of the plot end in the middle of the graph.</para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>
                    <caution>
                        <para>Do not mix both manually and automatically assigned colors. When the
                            library assigns colors to a new line plot it will not check if a certain
                            color has been previously manually set and used.</para>
                    </caution>
                </para>
            </sect2>
            <sect2>
                <title>Adding a second Y-axis</title>
                <para>As was discussed in <xref xlink:href="#sec1.multiple-yaxis"/> it is possible
                    to add multiple y-axis to a graph. The most common use of this feature is to
                    just use one extra y-axis with a different scale on the right side of the graph.
                    To make this common case as easy as possible to manage the library provides some
                    convenience method to work with one second y-axis (and scale).</para>
                <para>The second y-axis is accessed through the "<code>$y2axis</code>" property of
                    the Graph class and its use is completely analogue to the primary y-axis
                        ("<code>$yaxis</code>").</para>
                <para>As you saw in the preceding example you could add multiple plots to the same
                    graph and Y-axis. However what if the two plots you want to display in the graph
                    has very different ranges? One might for example have Y-values like above but
                    the other might have Y-values in the 100:s. Even though it is perfectly possible
                    to add them as above the graph with the smallest values will have a very low
                    dynamic range since the scale must accommodate for the bigger dynamic range of
                    the second plot. (One other way of solving this particular problem could be to
                    use a logarithmic y-scale).</para>
                <para>The solution to this is to use a second Y-axis with a different scale and add
                    the second plot to this Y-axis instead. Let's take a look at how that is
                    accomplished.</para>
                <para>First we need to create a new data array with large values and secondly we
                    need to specify a scale for the Y2 axis. This is done by adding the lines</para>
                <para>
                    <programlisting>&lt;?php
$y2data = array(354 , 200 , 265 , 99 , 111 , 91 , 198 , 225 , 293 , 251);
$graph->SetY2Scale('lin');
?></programlisting>
                </para>
                <para>To instruct the library to add this data series to the second y-axis we have
                    to make use of the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>Graph::AddY2()</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>which is used in analogy with the usual Graph::Add()</para>
                <para>To make the graph easier to read we set the color of the second y-axis to be
                    the same as the second data series. The result of this is shown in <xref
                        xlink:href="#fig.example5"/> below.</para>
                <para>
                    <programlisting>#=example5|Adding a second y-axis to the graph#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Adding a legend box to the graph</title>
                <para>Once we have multiple data series there is a need to separate them and that is
                    usually done by adding a legend box with suitable titles. As was shown in <xref
                        xlink:href="#sec1.adjusting-legend-position"/> it is possible to both add a
                    legend box and adjusts its position. Lets now continue the previous example by
                    adding a suitable legend box to separate the two data series.</para>
                <para>Each plot type has a '<code>SetLegend()</code>' method which is used to name
                    that plot in the legend. So to name the two plots in the previous example we
                    have been working with so far we need to add the two lines</para>
                <para>
                    <programlisting>&lt;?php
$lineplot->SetLegend('Plot 1');
$lineplot2->SetLegend('Plot 2');
?></programlisting>
                </para>
                <para>As you can see the legend gets automatically sized depending on how many plots
                    there are that have legend texts to display. By default it is placed with it's
                    top right corner close to the upper right edge of the graph. Depending on the
                    image you might want to adjust this or you might want to add a larger margin
                    which is big enough to accompany the legend. Let's do both.</para>
                <para>First we increase the right margin and then we place the legend so that it is
                    roughly centered in the right margin area. We will also enlarge the overall
                    image so the plot area doesn't get too squeezed.</para>
                <para>The legend properties is accessed through the '<code>$legend</code>' property
                    of the graph. So in order to adjust the position (as was described in <xref
                        xlink:href="#sec1.adjusting-legend-position"/> ) we add the line</para>
                <para>
                    <programlisting>$graph->legend->SetPos(0.05, 0.5, 'right', 'center');</programlisting>
                </para>
                <para>This will then give the graph shown in <xref xlink:href="#fig.example6"
                    /></para>
                <para>
                    <programlisting>#=example6|Adding and adjusting the position of the legend box#</programlisting>
                </para>
                <para>As a reminder we briefly discuss the working of the <code>SetPos()</code>
                    method.</para>
                <para>The position is specified as a fraction of the overall width and height of the
                    entire graph. This makes it possible for to resize the graph without disturbing
                    the relative position of the legend. The second two arguments specifies the
                    anchor point in the legend box that should be aligned with the specified
                    position.</para>
                <para>As can be seen in <xref xlink:href="#fig.example6"/> the legends are by
                    default placed in a column. It is also possible to adjust this by calling either
                    the <code>Legend::SetLayout()</code> method or specifically set the number of
                    columns to use by calling <code>Legend::SetColumns()</code> . Lets change the
                    layout so the legend texts are set in one row and place the legend box at the
                    bottom of the graph. If we do this we get the result shown in <xref
                        xlink:href="#fig.example6.1"/></para>
                <para>
                    <programlisting>#=example6.1|Adjusting the layout of the texts in the legend box#</programlisting>
                </para>
                <para>As a final example lets combine what we have learnt up to now, i.e. adding
                    plot marks, adding multiple data series to the same graph and adding a legend
                    box into one example. In <xref xlink:href="#fig.builtinplotmarksex1"/> we have
                    in addition used the feature with "tabbed" titles which is an alternative way to
                    put titles on graph (as discussed in <xref
                        xlink:href="#sec2.fomratting-graph-titles"/>).</para>
                <para>
                    <programlisting>#=builtinplotmarksex1|Using plot marks with several data series and a legend#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Changing the style of the line plot - using the step-style</title>
                <para>Step style refers to an alternate way of rendering line plots by not drawing a
                    direct line between two adjacent points but rather draw two segments. The first
                    segment being a horizontal line to the next X-value and then a vertical line
                    from that point to the correct Y-value at that instance. This is also known as
                    "zero-order hold" (as compared with the first-order hold which is an alternative
                    name for combining each data point with a straight line). Enabling step styl√∂e
                    is done by calling the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>LinePlot::SetStepStyle($aFlg=true)</code><xref
                                    xlink:href="#fig.filledlineex01.1"/></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>In <xref xlink:href="#fig.example6.2"/> we have enabled the step style for a
                    basic line graphs to illustrate this concept.</para>
                <para>
                    <programlisting>#=example6.2|Using the "Step style" for line plots#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Optimizing line plot using "fast drawing"</title>
                <para>For line plots with a large amount of data point that is drawn with a solid
                    line it is possible to speed up the construction of the graph by calling the method:<itemizedlist>
                        <listitem>
                            <para><code>LinePlot::SetFastStroke($aFlg=true)</code></para>
                        </listitem>
                    </itemizedlist></para>
                <para>This will avoid some of the overhead associated with drawing lines of
                    arbitrary style. The limitations with this optimization is</para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>Only solid lines, no styles on the lines are allowed (including no
                                step-style)</para>
                        </listitem>
                        <listitem>
                            <para>No plot marks</para>
                        </listitem>
                        <listitem>
                            <para>No value labels</para>
                        </listitem>
                        <listitem>
                            <para>No area plot , i.e. no filled line graphs and no filled partial
                                areas</para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>For line plots with a large amount of data point the savings can be quite
                    substantially and in the order of 40-50% speedup.</para>
            </sect2>
            <sect2 xml:id="sec2.creating-area-graph">
                <title>Creating a filled line graphs (a.k.a. area plots)</title>
                <para>A filled line plot (also known as an area plot) can be created in two ways
                    depending on whether automatic color handling is sufficient or there is a need
                    to manually specify the color.</para>
                <para><orderedlist>
                        <listitem>
                            <para><emphasis role="bold">Case 1: Using automatic fill
                                    color</emphasis></para>
                            <para>In this case there is only need to tell that we want t filled line
                                graph by calling the method</para>
                            <para>
                                <itemizedlist>
                                    <listitem>
                                        <para><code>LinePlot::SetFilled($aFlg=true)</code></para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                            <para>The color assigned to the filled area will be set
                                automatically</para>
                        </listitem>
                        <listitem>
                            <para><emphasis role="bold">Case 2: Setting a manual fill
                                    color</emphasis></para>
                            <para>In this case the method called to set the fill color will make an
                                implicit call to <code>SetFilled()</code>. Setting the fill color is
                                done by the method</para>
                            <para>
                                <itemizedlist>
                                    <listitem>
                                        <para><code>LinePlot::SetFillColor($aColor)</code></para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                        </listitem>
                    </orderedlist>In <xref xlink:href="#fig.filledlineex01"/> a basic filled line
                    graph is shown which also have plot marks and an adjusted color so that the line
                    and the fill have different colors.</para>
                <para>
                    <programlisting>#=filledlineex01|A basic filled line graph#</programlisting>
                </para>
                <para>There are a couple of thing worth noting</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>If you add multiple filled line plots to one graph make sure you
                                add the one with the highest Y-values first since it will otherwise
                                overwrite the other plots and they will not be visible. Plots are
                                stroked in the order they are added to the graph, so the graph you
                                want front-most must be added last.</para>
                        </listitem>
                        <listitem>
                            <para>When using legends with filled line plot the legend will show the
                                fill color and not the bounding line color.</para>
                        </listitem>
                        <listitem>
                            <para>The area filled is the area between the x-axis at y=0 and the data
                                value</para>
                        </listitem>
                        <listitem>
                            <para>By default the line color will be the same as the fill color. This
                                means that if a different line color is needed then the call to
                                    <code>LinePlot::SetColor()</code> must be <emphasis role="bold"
                                    >after</emphasis> the call to
                                    <code>LinePlot::SetFillColor()</code></para>
                        </listitem>
                        <listitem>
                            <para>Grid lines are by default drawn behind the plot (or rather the
                                plot is drawn on top of the plot area). However, this can be
                                adjusted so that the grid lines will always be on top of the line
                                plots. This is done by calling the method</para>
                            <para>
                                <itemizedlist>
                                    <listitem>
                                        <para><code>Graph::SetGridDepth($aDepth)</code> where
                                                <code>$aDepth</code> is either
                                                <code>DEPTH_BACK</code> or <code>DEPTH_FRONT</code>
                                            symbolic defines</para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                            <para>An alternative way of handling this is to make the fill color
                                semi-transparent by setting the alpha-blending for the fill color.
                                See <xref xlink:href="#sec2.alpha-channel"/> and <xref
                                    xlink:href="#fig.builtinplotmarksex1"/> above for a real
                                example. Just making this grid depth adjustments will give the
                                result shown in <xref xlink:href="#fig.filledlineex01.1"/></para>
                            <para>
                                <programlisting>#=filledlineex01.1|Having the grid line on top of a filled line plot#</programlisting>
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
                <tip>
                    <para>By default the fill is only done between y=0 and the line plot. In some
                        cases it might be useful to have the fill go all the way down to whatever
                        the minimum y-value is (for example if the x-axis is always positioned at
                        the minimum y-value). This can be accomplished by calling the method</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>LinePlot::SetFillFromYMin($aFlg=true)</code></para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </tip>
                <sect3>
                    <title>Filling from the top</title>
                    <para>As was mentioned in the previous paragraph the fill normally goes from the
                        bottom and up to the line specified by the data series. Another variant is
                        to have the fill go from the top of the plot area down to the line. </para>
                    <para>There is primary one use for this type of fill and that is to create a
                        "mask" for a background image to make the illusion that the area below the
                        line is filled with the image while the area above the line is the normal
                        plot background.</para>
                    <para>This is done by first telling the library the fill shall be from the top
                        with a call to the method</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>LinePlot::SetFillFromYMax($aFlg=true)</code></para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>then we create the data series as usual but specify the fill color as the
                        wanted background color and also add the image we want as a background
                        image.</para>
                    <para>Since we only want to use the first plot as a mask we can also specify the
                        line weight to 0 (to avoid the edge lines of the plot going from the first
                        and last point to the top. To have a nice line we can just add a second line
                        plot which is not filled and is just used to draw the line in our specified
                        color and weight. </para>
                    <para>An example of how this can look is shown in <xref
                            xlink:href="#fig.lineimagefillex1"/> below which shows a fictive growth
                        in education which is illustrated with an old class room photography.</para>
                    <para>
                        <programlisting>#=lineimagefillex1|Creating the effect of an area fill with an image#</programlisting>
                    </para>
                    <para>
                        <tip>
                            <para>To have the grid lines on top of the area plot (so they are
                                visible since they are vy default drawn at the bottom) the depth of
                                the grid lines can be set with a call to the method</para>
                            <para>
                                <itemizedlist>
                                    <listitem>
                                        <para><code>Graph::SetGridDepth($aDepth)</code></para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                            <para>For example as in</para>
                            <para>
                                <programlisting>$graph->SetGridDepth(DEPTH_FRONT);</programlisting>
                            </para>
                        </tip>
                    </para>
                </sect3>
                <sect3>
                    <title>Filling from 0 or from bottom</title>
                    <para>As a complement to what was described in the previous section it is also
                        possible to fill from the bottom. By default an area is filled from the
                        0-line to the boundary of the data series as is shown in <xref
                            xlink:href="#fig.manualtickex3"/> below</para>
                    <para>
                        <programlisting>#=manualtickex3|Filling from the 0-line (The default)#</programlisting>
                    </para>
                    <para>By making a call to</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>LinePlot::SetFillFromYMin($aFlg=true)</code></para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>The area will instead be filled from the bottom as is shown in <xref
                            xlink:href="#fig.manualtickex4"/></para>
                    <para>
                        <programlisting>#=manualtickex4|Filling from the bottom#</programlisting>
                    </para>
                    <para>
                        <note>
                            <para>In <xref xlink:href="#fig.manualtickex3"/> and <xref
                                    xlink:href="#fig.manualtickex4"/> we have used gradient fill in
                                both the plot area and the amrgin area. This is a feature that was
                                introduced in free-version3.0.5 and in pro-version 3.1.3p</para>
                        </note>
                    </para>
                </sect3>
                <sect3>
                    <title>Using gradient fills</title>
                    <para>In addition to the solid color fill it is also possible to use gradient
                        fills for are graphs. To specify a gradient fill for a line graph the
                        following method in LinePlot class is used</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>LinePlot::SetFillGradient($aFromColor,$aToColor,$aNumColors=100,$aFilled=true)</code></para>
                                <para><code>$aFromColor</code>, <code>$aToColor</code>, The starting
                                    and ending color</para>
                                <para><code>$aNumColors=100</code>, The number of colors to use in
                                    the transition between from and to color</para>
                                <para><code>$aFilled=true</code>, Enable/disable gradient
                                    filling</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>Some examples of typical use of this is shown below</para>
                    <para>
                        <programlisting>#=gradlinefillex1|A basic gradient fill using default values#</programlisting>
                    </para>
                    <para>The following two examples shows the effect of changing the number of
                        intermediate colors that are used to get from the "from color" and to the
                        "to color".</para>
                    <para>
                        <informaltable frame="none">
                            <tgroup cols="2">
                                <colspec colname="c1" colnum="1"/>
                                <colspec colname="c2" colnum="2"/>
                                <tbody>
                                    <row>
                                        <entry>
                                            <programlisting>#=gradlinefillex2|Using the default number of intermediate colors#</programlisting>
                                        </entry>
                                        <entry>
                                            <programlisting>#=gradlinefillex3|Only using 4 colors in total between start and finish color#</programlisting>
                                        </entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </informaltable>
                    </para>
                </sect3>
            </sect2>
            <sect2>
                <title>Partially filled area graphs</title>
                <para>In addition to filling the entire area between the line plot and the x-axis
                    (at y=0) the library also offers the possibility to add areas limited by the
                    line and a specified interval on the x-axis. Several such areas can be added and
                    each area having a different color. In ?? a basic example of how this can look
                    is shown.</para>
                <para>
                    <programlisting>#=partiallyfilledlineex1|Adding two partially filled areas to a line plot#</programlisting>
                </para>
                <para>The areas (one or more) are created by calling the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>LinePlot::AddArea($aMin=0,$aMax=0,$aFilled=LP_AREA_NOT_FILLED,$aColor="gray9",$aBorder=LP_AREA_BORDER)</code></para>
                            <para>The extension of the area along the x-axis is given by the
                                    <code>$aMin</code> and <code>$aMax</code> values. </para>
                            <para>The third argument specifies whether the area should be filled or
                                not. This argument can have the values</para>
                            <para>
                                <itemizedlist>
                                    <listitem>
                                        <para><code>LP_AREA_FILLED</code></para>
                                    </listitem>
                                    <listitem>
                                        <para><code>LP_AREA_NOT_FILLED</code></para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                            <para>The fourth argument specifies the fill color and the fifth
                                argument specifies if the area should have a border (edge) or not.
                                If the area has a border it will be the same color as the line. The
                                values for the fourth argument can be</para>
                            <para>
                                <itemizedlist>
                                    <listitem>
                                        <para><code>LP_AREA_BORDER</code></para>
                                    </listitem>
                                    <listitem>
                                        <para><code>LP_AREA_NO_BORDER</code></para>
                                    </listitem>
                                </itemizedlist>
                            </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect2>
            <sect2>
                <title>Filled lines with NULL values</title>
                <para>The NULL value handling follows the same principle as was described for line
                    plots. If the NULL value is specified as '-' the line will be interpretated but
                    if it is specified as 'x' it will be broken up as is shown in <xref
                        xlink:href="#fig.filledlineex03"/></para>
                <para>
                    <programlisting>#=filledlineex03|Area plot with 'x' NULL values#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Accumulated line graphs</title>
                <para>Accumulated line graphs are line graphs that are "stacked" on top of each
                    other. That is, the values in the supplied data for the Y-axis is not the
                    absolute value but rather the relative value from graph below. For example if
                    you have two line graphs with three points each, say [3,7,5] and [6,9,7]. The
                    first graph will be plotted on the absolute Y-values [3,7,5] the second plot
                    will be plotted at [3+6, 7+9, 5+7], hence the values of the previous graphs will
                    be used as offsets.</para>
                <para>An accumulated graph plot is represented by <code>class AccLinePlot</code>
                    which is a container class for line plots. This means that the
                        <code>AccLinePlot</code> needs to be "fed" a number of ordinary instances of
                        <code>LinePlot</code>.</para>
                <para>Any number of ordinary line graphs may be added together (up to the limit of
                    readability of the plot).</para>
                <para>For example, to add three line plots in an accumulated line plot graph the
                    following code is needed</para>
                <para>
                    <programlisting>&lt;?php
// First create the individual plots
$p1 = new LinePlot( $datay_1 );
$p2 = new LinePlot( $datay_2 );
$p3 = new LinePlot( $datay_3 ); 

// Then add them together to form a accumulated plot
$ap  = new  AccLinePlot(array( $p1 , $p2 , $p3 ));

// Add the accumulated line plot to the graph
$graph->Add ( $ap ); 
?></programlisting>
                </para>
                <para>Using some random data for the areas can produce the result shown in <xref
                        xlink:href="#fig.example17"/></para>
                <para>
                    <programlisting>#=example17|A basic accumulated area plot#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Accumulated line graphs with given X-labels</title>
                <para>Creating an accumulated line plot, (or a filled accumulated area plot), with
                    multiple data sets at given x-coordinates poses some specific problems when the
                    coordinates for the different data sets are not given at the same x-coordinates.
                    This is a generic problem and has nothing to do with library in particular. This
                    section wil deal with one possible way of handling this by making sure that
                    missing data points are created if they are "missing".</para>
                <para>To understand the problem we will make one simplifications (that is of no real
                    consequence for the end result) that can be stated as </para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>the X-coordinates for all data tuples are whole positive number.
                            </para>
                        </listitem>
                        <listitem>
                            <para>the X-coordinates are in sorted order (non-descending) </para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>The core issue can be illustrate as follows. Lets assume that we want to make
                    an accumulated graph showing the two data sets </para>
                <para>
                    <screen>data set 1 == (0,5), (2,10), (3,10), (5,20)
data set 2 == (0,7), (1,12), (2,5),  (5,10)
</screen>
                </para>
                <para>In the above notation the tuple (0,5) means a data point with X-coordinate = 0
                    and Y-coordinate = 5. </para>
                <para>What the library now needs to do is to first plot data set 1. No problem. When
                    it then becomes time to plot the second data set we face an issue. The only
                    points where we now the Y-value of data set 1 is at the given discrete points
                    (0,2,3,5). </para>
                <para>Plotting the first tuple for data set 2 shown above gives an absolute starting
                    point at </para>
                <para>
                    <screen>(0,5+7) == (0,12)
</screen>
                </para>
                <para>The next data point we know for data set 2 is (1,12) so we need to plot this.
                    But now we can see that we do not know the value for data set 1 at X-coordinate
                    = 1. We only know the values at coordinates 0 and 2. This gives us a problem. We
                    need to know at what offset we should plot this data point in data set 2 and we
                    have no direct way of calculating this. </para>
                <para>Now, one might argue that we could just interpolate between the data points
                    (0,5) and (2,10) the Y-value at X=1 (doing a linear interpolation this would
                    give the data point (1,7.5)) so why doesn't the library simply do this? It
                    surely could be done. </para>
                <para>
                    <note>
                        <para>In real life using this approach would be much more complex. First of
                            all we need to create a linear succession of all X-values used in all
                            data sets to create an ordered set and then fill in the blanks so that
                            all data sets have values at all given X-coordinates. Those of you
                            familiar with signal processing will recognize this as an (almost)
                            up-sampling of the original data sets followed by a low pass filter.
                        </para>
                    </note>
                </para>
                <para>However, by design the library doesn't do this. The crucial observation here
                    is that it can not be a graphic libraries responsibility to "create" missing
                    data points by making assumption that a particular polynomial interpolation is
                    valid (in this case a first degree approximation). What if a linear
                    interpolation is not representative for the data set given? Perhaps a second
                    degree approximation would be more accurate. </para>
                <para>So, this kind of data preparation must be done in the domain of the given data
                    set where knowledge of the underlying data will allow an accurate preparation of
                    the input to a graphing script if we insist of plotting an accumulated graph.
                    One could argue that accumulated data plots can only be done for data series
                    with the same X-coordinates. </para>
                <sect3>
                    <title>Preparing the input data</title>
                    <para>So what if we are still required to do an accumulated plot even when we
                        don't have all the data sets at the same X-coordinates? Going back to our
                        original two data sets, hereafter referrered to as DS1 and DS2 there are 2
                        manual steps (as described above) that needs to happen. </para>
                    <para>
                        <orderedlist>
                            <listitem>
                                <para>Identify all X-data points that needs to exist </para>
                            </listitem>
                            <listitem>
                                <para>Create values for all data sets at those points </para>
                            </listitem>
                        </orderedlist>
                    </para>
                    <para>So, in DS1 and DS2 the union of the two data sets X-coordinates are </para>
                    <para>
                        <screen>X_coordinates == union(DS1_x, DS2_x) == 0,1,2,3,5
</screen>
                    </para>
                    <para>This will force us to augment the two data sets as </para>
                    <para>
                        <screen>data set 1 == (0,5), (1,??), (2,10), (3,10), (5,20)
data set 2 == (0,7), (1,12), (2, 5), (3,??), (5,10)
</screen>
                    </para>
                    <para>Where I have added '??' to indicate values that needs to be computed in
                        order to draw an accumulated line/area plot at specific values. Now assume
                        that we are able to find the missing data for these points by some method to
                        be </para>
                    <para>
                        <screen>data set 1 == (0,5), (1, 8), (2,10), (3,10), (5,20)
data set 2 == (0,7), (1,12), (2, 5), (3, 2), (5,10)
</screen>
                    </para>
                    <para>Are we now ready to plot these data sets? Unfortunately not quite. The
                        remaining problem is that since the library only handles accumulated plots
                        without a given X-coordinate (using an X-coordinate for the individual line
                        plots will have no affect - and it's behaviour is undefined). This means
                        that the data points are assumed to be equ-distance apart - and this is
                        almost true for the data sets above. There is 1 unit between theme apart
                        from the two last tuples which in fact have a distance of 2 units. In fact
                        the library only plots data sets with a given Y-coordinate and then assumes
                        that the x-coordinate is a linear ordering of (0,1,2, ..) </para>
                    <para>So in order to create a linear equ-distance ordered set we need to further
                        augment the two data sets as </para>
                    <para>
                        <screen>data set 1 == (0,5), (1, 8), (2,10), (3,10), (4,??), (5,20)
data set 2 == (0,7), (1,12), (2, 5), (3, 2), (4,??), (5,10)
</screen>
                    </para>
                    <para>So this means that we need to manually calculate another interpolated
                        value. If we know we can make a linear interpolation (or perhaps find the
                        data at this point) it will give us </para>
                    <para>
                        <screen>data set 1 == (0,5), (1, 8), (2,10), (3,10), (4,15), (5,20)
data set 2 == (0,7), (1,12), (2, 5), (3, 2), (4, 6), (5,10)
</screen>
                    </para>
                    <para>This final data set is now ready to be sent to the
                            <code>AccLinePlot</code> class. It is left as a (non-trivial) exercise
                        to the reader to define and implement a function that performs the steps
                        outlined above to create proper data sets before reading on.</para>
                </sect3>
                <sect3>
                    <title>Creating plots with non-trivial X-coordinates</title>
                    <para>With non-trivial X-coordinates we mean for example timestamps or perhaps
                        real numbers. For timestamps it is not so difficult. What we need to do is
                        to identify the proper interval (in the original timestamp domain) and then
                        create a mapping between that domain and the natural numbers (0,1,2,3,...). </para>
                    <para>The reason for this is that the library only accepts Y-coordinates as
                        argument to the accumulated data series and will make the implicit
                        assumption that when it plots the data it will plot the data points at
                        consecutive values as if the X-coordinates had been given as (0,1,2,3,..).
                        Hence we need to manually prepare the data to match this format. </para>
                    <para>As the final step we manually set the labels for the X-axis according to
                        our interpretation. An example (with some code snippets) will make this
                        approach clear. </para>
                    <para><emphasis role="bold">Example - using timestamps</emphasis></para>
                    <para>Assume we have the two data sets with timestamps </para>
                    <para>
                        <screen>DS1 == (1212199200,12), (1212210000,20), (1212213600,30)
DS1 == (1212199200,12), (1212206400, 8)
</screen>
                    </para>
                    <para>and we now that the sampling interval between the data points are 7200s
                        (=2 min). Following the same principle as above we need to find the
                        additional values</para>
                    <para>
                        <screen>DS1 == (1212199200,12), (1212206400,??), (1212210000,20), (1212213600,30)
DS1 == (1212199200,12), (1212206400, 8), (1212210000,??), (1212213600,??)
</screen>
                    </para>
                    <para>further assuming that we (by some method) can find these value we can then
                        interpret this data as </para>
                    <para>
                        <screen>DS1 == (1212199200,12), (1212206400,16), (1212210000,20), (1212213600,30)
DS1 == (1212199200,12), (1212206400, 8), (1212210000, 0), (1212213600, 0)
</screen>
                    </para>
                    <para>In the above we have made the explicit assumption that unknown data points
                        at the end can be interpretated as 0 in this particular application. </para>
                    <para>We now have an ordered sequence of these tuples and we can imagine a
                        mapping that will allow us to write these sequences as </para>
                    <para>
                        <screen>DS1 == (0,12), (1,16), (2,20), (3,30)
DS1 == (0,12), (1, 8), (2, 0), (3, 0)
</screen>
                    </para>
                    <para>The mapping for this is <code>xi=1212199200 + 7200*i, i=0..3</code> which
                        we use when we put the final labels in the graph. </para>
                    <para>The only steps that remain to handle timestamps is to manually replace the
                        X-scale (which in this case would be 0,1,2,3) with the calculated values
                        according to the mapping given above. </para>
                    <para>We do this by creating an array of the timestamps we need to plot and then
                        replace them - in situ - with an application of the standard PHP function
                            <code>array_walk()</code> which applies a user defined function to each
                        value in an array and replaces that value with the return value of the user
                        function. In this case we create a user function that implements the mapping
                        stated above with the additional twist that given an argument as a time
                        stamp it returns a suitable human format for that time stamp. </para>
                    <para>The following code fragments shows how this could be done </para>
                    <para>
                        <programlisting>// Some userdefined human readable version of the timestamp
function formatDate(&amp;$aVal) {
    $aVal = date('Y-m-d H:i',$aVal);
}

$timeStamps = array(212199200,1212206400,1212210000,1212213600);

array_walk($time,'formatDate');</programlisting>
                    </para>
                    <para>when we now have the labels in a nice human readable format we can put
                        them on the scale labels with </para>
                    <para>
                        <programlisting>$graph->xaxis->SetTickLabels($timeStamps);
$graph->xaxis->SetLabelAngle(90);</programlisting>
                    </para>
                    <para>though strictly not necessary we have also tilted the labels 90 degrees in
                        order to minimize the risk the labels overwrite each other. </para>
                    <para>If we still think that the labels are too close together ea we can chose
                        to only label every second tick mark. We do this with a call to </para>
                    <para>
                        <programlisting>$graph->xaxis->SetTextLabelInterval(2);</programlisting>
                    </para>
                    <para><emphasis role="bold">Example using real (i.e. floating point)
                            x-coordinates</emphasis></para>
                    <para>In principle this is handled in the same way as what we shown above for
                        timestamps. The additional complexity here spells rounding errors. When we
                        establish the equidistant interval between each data point it will be a real
                        number, potentially an irrational number, which means that we cannot
                        represent it exactly and adding the interval repeated times might cause
                        rounding errors if we are not careful. </para>
                    <para>Secondly we need to find a mapping between the ordered sequence of the
                        real numbers we have as X-coordinates and the natural numbers which are the
                        implicit X-coordinates assumed by the library. </para>
                </sect3>
                <sect3>
                    <title>A full example</title>
                    <para>In the example below we artifically create some data sets where all the
                        sets have values at all specified timestamps with the following code </para>
                    <para>
                        <programlisting>&lt;?php
//Create some test data
$xdata = array();
$ydata = array();

// Timestamps - 2h (=7200s) apart starting 
$sampling = 7200;
$n = 50; // data points

// Setup the data arrays with some random data
for($i=0; $i &lt; $n; ++$i ) {
    $xdata[$i] = time() + $i * $sampling;
    $ydata[0][$i] = rand(12,15);
    $ydata[1][$i] = rand(100,155);
    $ydata[2][$i] = rand(20,30);
}
?></programlisting>
                    </para>
                    <para>Since the xdata array is given as timestamps we need to make this more
                        human readable by converting the timestamp using the <code>date()</code>
                        function. To do this we create an axillary helper function and then use the
                            <code>array_walk() </code>standard array function to apply this
                        formatting to all existing values in the timestamp array as follows. </para>
                    <para>
                        <programlisting>// Formatting function to translate the timestamps into human readable labels
function formatDate(&amp;$aVal) {
    $aVal = date('Y-m-d H:i',$aVal);
}

// Apply this format to all time values in the data to prepare it to be display
array_walk($time,'formatDate');</programlisting>
                    </para>
                    <para>The core of the script can now be written. For a change we make some
                        adjustment from the default values of colors and tick mark positioning as a
                        reminder that there is a lot of flexibility in creating the graphs. </para>
                    <para>
                        <programlisting>&lt;?php
// Create the graph. 
$graph  = new Graph(700, 400);
$graph->title->Set('Accumulated values with specified X-axis scale');
$graph->SetScale('datlin');

// Setup margin color
$graph->SetMarginColor('green@0.95');

// Adjust the margin to make room for the X-labels
$graph->SetMargin(40,30,40,120);

// Turn the tick marks out from the plot area
$graph->xaxis->SetTickSide(SIDE_BOTTOM);
$graph->yaxis->SetTickSide(SIDE_LEFT);

$p0 =new LinePlot($a);
$p0->SetFillColor('sandybrown');
$p1 =new LinePlot($b);
$p1->SetFillColor('lightblue');
$p2 =new LinePlot($c);
$p2->SetFillColor('red');
$ap = new AccLinePlot(array($p0,$p1,$p2));

$graph->xaxis->SetTickLabels($time);
$graph->xaxis->SetTextLabelInterval(4);

// Add the plot to the graph
$graph->Add($ap);

// Set the angle for the labels to 90 degrees
$graph->xaxis->SetLabelAngle(90);

// Send the graph back to the browser
$graph->Stroke();
?></programlisting>
                    </para>
                    <para>The resulting image will now look something like what is shown in
                        ??</para>
                    <para>
                        <programlisting>#=prepaccdata_example|Area plot with specified x coordinates#</programlisting>
                    </para>
                </sect3>
                <sect3>
                    <title>Helper function to create interpolated data</title>
                    <para>The function <code>InterpolateData()</code> below takes two array of
                        arrays and one integer as arguments. The first array of arrays contains the
                        X-coordinates for each data set and the second array of arrays contains the
                        Y-coordinates for all the data sets. The final integer argument is the
                        distance (or sample rate) that should be assumed between each X-coordinate. </para>
                    <para>The function will return a tuple. The first element in the returned tuple
                        is a single array with all the X-values that should be used and the second
                        element is an array of arrays with all the Y-data sets with all data
                        specified for each X-coordinate. Any missing Y values are interpolated using
                        a linear interpolation schema. </para>
                    <para>So using our first example above as demonstration this would be handled as </para>
                    <para>
                        <programlisting>&lt;?php
$datax = array( 
    array(0,2,3,5),
    array(0,1,2,5));

$datay = array(
    array(5,10,10,20),
    array(7,12,5,10));

list($datax, $datay) = InterpolateData($datax, $datay);

// $datax = array(0,1,2,3,4,5)
// $datay = array( array(5, 8,10,10,15,20),
//                 array(7,12, 5, 2, 6,10));
?></programlisting>
                    </para>
                    <para>One possible implementation of this function is given below. It has
                        primarily been written for clarity and not necessary high performance. To
                        interpolate the "missing" Y-values a linear approximation is assumed. </para>
                    <para>
                        <programlisting>&lt;?php
function InterpolateData($aXData,$aYData,$aSampleInterval=1) {

    // First do some sanity checks on the input data
    $nx = count($aXData);
    $ny = count($aYData);
    if( $nx != $ny )
        return array(false,-1);
        
    for( $i=0; $i &lt; $nx; ++$i ) {
         if( count($aXData[$i]) != count($aYData[$i]) )
             return array(false,-2);
    }

    // Create the sorted union of all X-coordinates
    $unionx = array_union($aXData);
    $length = count($unionx);

    // We now have to make sure that the distance between all
    // X-coordinates is 1 unit of the sample interval. If not
    // we will have to insert suitable X-value
    $i=1;
    while( $i &lt; $length ) {
	        $missing = 0;
        	$diff = $unionx[$i] - $unionx[$i-1];
        	if( $diff != $aSampleInterval ) {

            // Sanity check to make sure sample interval is an even multiple
            // of the distance between the gven X-coordinates
            if( $diff % $aSampleInterval !== 0 ) {
              return array(false,-4);
            }

	            $missing = $diff / $aSampleInterval - 1;
    	        $fill = array();
    	        for( $j=0; $j &lt; $missing; ++$j ) {
                		$fill[$j] = $aSampleInterval*($j+1)+$unionx[$i-1];
    	        }
    	        $unionx = array_merge(
                		array_slice($unionx,0,$i),$fill,array_slice($unionx,$i));
         	}
         	$i += $missing+1;
         	$length += $missing;
    }    

    if( $length != count($unionx) ) {
        // Internal error check
        return array(false,-3);
    }

    // Now loop through all the individual data sets and find out 
    // which x-data is missing and hence needs to be interpolated
    $n = count($aXData);

    for( $i=0; $i &lt; $n; ++$i ) {
        	$missing_values = array_diff($unionx, $aXData[$i]);

        	// Now find the position of each missing X-coordinate
        	// and use that position in the corresponding Y array
        	// to insert an interpolated value
        	$m = count($missing_values);
        	foreach( $missing_values as $key => $val ) {
        	    $idx = array_search($val,$unionx);

        	    // Now split the Y-array at that position and insert
        	    // a new sentinel value
        	    if( $idx >= 0 ) {
                		$aYData[$i] = array_merge(
            		        array_slice($aYData[$i],0,$idx),
            		        array(NULL),
            		        array_slice($aYData[$i],$idx));
        	    }
        	}

        	// The next step is to actually calculate an interpolated value
        	// for the Y-coordinates we don't have. As a special case any
        	// beginning or ending non-defined coordinates are set to 0
	
        	// Set all beginning NULL to 0
        	for( $j=0; $j &lt; $length; ++$j ) {
        	    if( $aYData[$i][$j] !== NULL )
                		break;
        	    $aYData[$i][$j] = 0;
        	}

        	// Set all ending NULL to 0
        	for( $j=$length-1; $j >= 0; --$j ) {
        	    if( $aYData[$i][$j] !== NULL )
                		break;
        	    $aYData[$i][$j] = 0;
        	}

        	// Calculate the remaingin missing values as a linear
        	// interpolation and keeping in mind that there might be
        	// multiple missing values in a row.
        	$j = 0;
        	while($j &lt; $length ) {
        	    if( $aYData[$i][$j] === NULL ) {
                		// How many unknown values in a row?
                		$cnt = 1;
                		while( $j+$cnt &lt; $length &amp;&amp; $aYData[$i][$j+$cnt]===NULL ) {
                		    ++$cnt;
                		}
        
                		if( $cnt == 1 ) {
                		    $aYData[$i][$j] = ($aYData[$i][$j-1]+$aYData[$i][$j+1])/2;
                		}
                		else {
                		    $step = ($aYData[$i][$j+$cnt] - $aYData[$i][$j-1])/($cnt+1);
                		    for( $k=1; $k &lt;= $cnt; ++$k ) {
                        			$aYData[$i][$j+$k-1] = $step*$k+$aYData[$i][$j-1];
                		    }
                		}
        	    }
        	    ++$j;
        	}
    }

    return array($unionx,$aYData);
}


//------------------------------------------------------------------------
// Helper function to create the union of two arrays
//------------------------------------------------------------------------

// Create the sorted union of all numeric arrays given as argument
function array_union($a) {

    $n = count($a);
    $res = $a[0];
    for( $i=1; $i &lt; $n; ++$i) {
        	$res = _array2_union($res,$a[$i]);
    }
    sort($res);
    return $res;
};

// Return the union between two numeric arrays
function _array2_union($a,$b) {

    if( $a == NULL ) return $b;
    if( $b == NULL ) return $a;

    // A standard "trick" to calculate the union of two arrays
    return array_merge(
        	array_intersect($a,$b),
        	array_diff($a, $b),
        	array_diff($b, $a));
}
?></programlisting>
                    </para>
                </sect3>
            </sect2>
            <sect2 xml:id="sec2.creating-cubic-splines">
                <title>Constructing smooth line plots with Cubic Splines</title>
                <para>The library support interpolation between data point by the use of cubic
                    splines. This will make the implicit assumption that the underlying phenomenon
                    that is plotted can be represented by a 3:rd degree polynomial between the given
                    data points (also known as a control points).</para>
                <para>Cubic splines have the property that the constructed line will pass through
                    all control points given.</para>
                <para>To construct a spline you both the X and Y coordinates for the known data
                    points are needed since the library can make no assumption on the step size
                    between the data points.</para>
                <para>The cubic spline functionality in the library is encapsulated in the
                        <code>class Spline</code> which is define the module
                        "<filename>jpgraph_regstat.inc.php</filename>" which must be added to the
                    included files in the script.</para>
                <para>The first step is to construct new Spline instance. This class is instantiated
                    by calling the constructor with the two known data arrays (X and Y) as
                    follows.</para>
                <para>
                    <programlisting>$spline = new Spline( $xdata , $ydata ); </programlisting>
                </para>
                <para>This call initializes the spline with the data points given. These data points
                    are also known as Control points for the spline. This helper class doesn't draw
                    any line itself. Instead it is merely used to get a new (larger) data array
                    which have all the interpolated values. These new value are then used to make
                    the actual line plot. This way gives great flexibility in how to use the
                    interpolated data points.</para>
                <para>To get the y- and x-axis data to be plotted we call the method
                        <code>Spline::Get()</code> to get an interpolated array containing a
                    specified number of points. So for example the line</para>
                <para>
                    <programlisting>list($sdatax , $sdatay) = $spline->Get( 50 ); </programlisting>
                </para>
                <para>will construct the two new data arrays '<code>$sdatax</code>' and
                        '<code>$sdatay</code>' which contains 50 data points. These two arrays are
                    constructed from the control points we specified when we created the
                        '<code>$spline</code>' object. These data arrays are then used to make the
                    actual plot just as for a "standard" plot. In <xref xlink:href="#fig.splineex1"
                    /> we have used 8 control points to construct a spline.</para>
                <para>
                    <programlisting>#=splineex1|Constructing a smooth spline curve from 8 control points#</programlisting>
                </para>
                <para>In order to make the example more interesting we actually used two plots.
                    First a line plot to get the smooth curve and then a standard scatter plot
                    (discussed later in this manual) which is used to illustrate where the control
                    points are situated.</para>
                <para>
                    <note>
                        <para>The library also support the construction of <emphasis role="italic"
                                >Bezier curves</emphasis> which is built on a similar concept of
                            constructing a smooth line from a number of control points, The biggest
                            difference between cubic splines and Bezier curves is that while a cubic
                            spline is always guaranteed to pass through all control point a Bezier
                            curve will in general not pass through any control points. Instead the
                            Bezier control point are outside the curve and affects the curvature of
                            the curve. Bezier type curves are not in general used together with data
                            visualization but are instead used to create specific curves, usually
                            for CAD and 3D graphic purposes. In the discussion of Canvas graphs, see
                                <xref xlink:href="#sec.canvas-graph"/>, we discuss this
                            further.</para>
                    </note>
                </para>
            </sect2>
        </sect1>
        <sect1 xml:id="sec1.creating-bar-graphs">
            <title>Bar graphs</title>
            <para>The library supports 2D vertical and horizontal bar plots as was shown in the
                introduction section . To use bar plots the bar plot module
                    "<filename>jpgraph_bar.php</filename>" must be included in the script.</para>
            <para>There are eight fundamental types of bar graphs supported by the library. Examples
                of the available types are shown in <xref xlink:href="#fig.types-of-barplots"
                /></para>
            <para>
                <figure xml:id="fig.types-of-barplots">
                    <title>Different types of supported bar graphs</title>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry align="center">
                                        <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/img_mmbar.png"
                                                /></imageobject></inlinemediaobject></para>
                                        <para><emphasis role="bold">a)</emphasis> Vertical
                                            bar</para>
                                    </entry>
                                    <entry align="center">
                                        <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/img_mmbar90.png"
                                                /></imageobject></inlinemediaobject></para>
                                        <para><emphasis role="bold">b)</emphasis> Horizontal
                                            bar</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry align="center">
                                        <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/img_mmaccbar.png"
                                                /></imageobject></inlinemediaobject></para>
                                        <para><emphasis role="bold">c)</emphasis> Vertical
                                            accumulated bar</para>
                                    </entry>
                                    <entry align="center">
                                        <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/img_mmaccbar90.png"
                                                  /></imageobject></inlinemediaobject></para>
                                        <para><emphasis role="bold">d)</emphasis> Horizontal
                                            accumulated bar</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry align="center">
                                        <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/img_mmgroupbar.png"
                                                  /></imageobject></inlinemediaobject></para>
                                        <para><emphasis role="bold">e)</emphasis> Vertical group
                                            bar</para>
                                    </entry>
                                    <entry align="center">
                                        <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/img_mmgroupbar90.png"
                                                  /></imageobject></inlinemediaobject></para>
                                        <para><emphasis role="bold">f)</emphasis> Horizontal group
                                            bar</para>
                                    </entry>
                                </row>
                                <row>
                                    <entry align="center">
                                        <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/img_mmgroupaccbar.png"
                                                  /></imageobject></inlinemediaobject></para>
                                        <para><emphasis role="bold">g)</emphasis> Vertical group
                                            accumulated bar</para>
                                    </entry>
                                    <entry align="center">
                                        <para><inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/img_mmgroupaccbar90.png"
                                                  /></imageobject></inlinemediaobject></para>
                                        <para><emphasis role="bold">h)</emphasis> Horizontal group
                                            accumulated bar</para>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </figure>
            </para>
            <para>Using bar plots is straightforward and works in much the same way as line plots as
                was discussed in the previous sections. </para>
            <para>An instance of <code>class BarPlot</code> is created with the wanted data and is
                then either added directly to the graph to create a basic bar plot or is enclosed in
                with one of the container classes <code>AccBarPlot</code> or
                    <code>GroupBarPlot</code> which are then added to the graph. </para>
            <para>There is however one crucial change that is usually made. The x-scale is usually
                specified as a "<code>text</code>" type scale. The reasons this are primarily
                two</para>
            <para>
                <orderedlist>
                    <listitem>
                        <para>to get the alignment of the labels to be between the tick marks and
                            not at the tick marks as is normal for line plots</para>
                    </listitem>
                    <listitem>
                        <para>to get the bars to be aligned at the center between the tick
                            marks</para>
                    </listitem>
                </orderedlist>
            </para>
            <para>The following two examples shows the difference between using an integer scale in
                    <xref xlink:href="#fig.example19.1"/> and a text sale in <xref
                    xlink:href="#fig.example19"/></para>
            <para>
                <informaltable frame="none">
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1"/>
                        <colspec colname="c2" colnum="2"/>
                        <tbody>
                            <row>
                                <entry>
                                    <programlisting>#=example19.1|Using "int" scale for the x-axis#</programlisting>
                                </entry>
                                <entry>
                                    <programlisting>#=example19|Using "text" scale for the x-axis#</programlisting>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>As can be seen in <xref xlink:href="#fig.example19.1"/> the bars have there left
                edge aligned with the data value and the tick mark (the tick mark can not be seen
                since it is aligned exactly with the left edge of the bar). In contrast using a text
                scale in <xref xlink:href="#fig.example19"/> adjusts the alignment of tick marks and
                labels in a way that is more commonly used with bar graphs.</para>
            <para>Some other commonly used method to change the appearance of the bar graphs
                are</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>BarPlot::SetFillColor($aColor)</code></para>
                        <para>This is used to specify the fill color of the bar. The argument can
                            also be an array and in that case each color in the array is used for
                            individual successive bars.</para>
                    </listitem>
                    <listitem>
                        <para><code>BarPlot::SetFillGradient($aFromColor,$aToColor=null,$aStyle=null)</code></para>
                        <para>Specifies a gradient fill style for the bars. See ?? for
                            details.</para>
                    </listitem>
                    <listitem>
                        <para><code>BarPlot::SetPattern($aPattern, $aColor='black')</code></para>
                        <para>Specifies a pattern to be used to fill the bars. See ?? for
                            details</para>
                    </listitem>
                    <listitem>
                        <para><code>BarPlot::SetWidth($aWidth)</code></para>
                        <para>Specifies the width of the individual bars. Of this is an integer
                            value > 1 it is interpretated as the absolute width in pixels. If the
                            values instead is a real number in the range [0,1] it is interpretated
                            as the fraction of the width between the tick marks. By default the
                            width is set to 0.4</para>
                    </listitem>
                </itemizedlist>
            </para>
            <sect2>
                <title>Accumulated bar plots</title>
                <para>Accumulated bar plots will show several data series stacked on top of each
                    other in each bar. They are the barplot variant of accumulated area plots as was
                    discussed previously.</para>
                <para>An accumulated bar plot is made by aggregating one or more basic bar plots in
                    the container class <code>AccBarPlot</code> as the following code snippet
                    shows</para>
                <para>
                    <programlisting>&lt;?php
// Some data
$data1y = ...
$data2y = ...

// Create two bar plots
$b1plot = new BarPlot($data1y);
$b1plot->SetFillColor('orange');
$b2plot = new BarPlot($data2y);
$b2plot->SetFillColor('blue');

// Create the accumulated bar plot
$gbplot = new AccBarPlot(array($b1plot,$b2plot));

// Add the accumulated plot to the graph
$graph->Add($gbplot);
?></programlisting>
                </para>
                <para>An example of an accumulated bar plot is shown in <xref
                        xlink:href="#fig.example23"/></para>
                <para>
                    <programlisting>#=example23|An accumulated bar plot#</programlisting>
                </para>
                <para>There are some subtleties when it comes to the formatting of the frames a
                    round each bar in an accumulated bar plots that might be useful to know. The
                    basic ambiguity that exists is that when we stack the bars on top of each other
                    to create a new accumulated bar each individual bar has properties that was (or
                    could) be set when each individual barplot was created like the frame around the
                    plot. </para>
                <para>For example, take the following basic accumulated bar plot (partial
                    script)</para>
                <para>
                    <programlisting>&lt;?php
// Create the first bar
$bplot = new BarPlot($datay1);
$bplot->SetFillGradient('AntiqueWhite2','AntiqueWhite4:0.8',GRAD_VERT);
$bplot->SetColor('darkred');

// And the second bar
$bplot2 = new BarPlot($datay2);
$bplot2->SetFillGradient('olivedrab1','olivedrab4',GRAD_VERT);
$bplot2->SetColor('darkgreen');

// Join them in an accumulated (stacked) plot
$accbplot = new AccBarPlot(array($bplot,$bplot2));
$graph->Add($accbplot);
?></programlisting>
                </para>
                <para>As you can see on line 5 and on line 10 we have set the frame color
                    differently in the two individual plots. However, the accumulated bar plot also
                    have a frame color property (and a weight as well) so what shall we use? If we
                    run a full example based on the lines above the result is shown in <xref
                        xlink:href="#fig.accbarframeex01"/> below.</para>
                <para>
                    <programlisting>#=accbarframeex01|Accumulated bar with individual frame colors#</programlisting>
                </para>
                <para>As can be seen from the graph the bar around each part has the color on th
                    frame that was set on the individual bar. There is one exception though. The
                    line that separates the two bars are shared and will always follow the color of
                    the top bar.</para>
                <para>If we instead specify a frame for the accbar by adding the lines</para>
                <para>
                    <programlisting>&lt;?php
$accbplot = new AccBarPlot(array($bplot,$bplot2));
$accbplot->SetColor('red');
$accbplot->SetWeight(1);
$graph->Add($accbplot);
?></programlisting>
                </para>
                <para>The result would be as is shown in <xref xlink:href="#fig.accbarframeex02"/>
                    and the properties of the accumulated bar takes precedence, again with one
                    exception. The divider lines inside the bar is still controlled by the
                    individual plot. By default the line weight on the accumulated bar is 0 which
                    means that it will not be drawn, that is why we have to set a line weight on
                    line 4 above.</para>
                <para>
                    <programlisting>#=accbarframeex02|Accumulated bar with unit frame color#</programlisting>
                </para>
                <para>If we instead were to set the individual line weight to zero, i.e.</para>
                <para>
                    <programlisting>&lt;?php
$bplot->SetWeight(0);
$bplot2->SetWeight(0);
?></programlisting>
                </para>
                <para>and keep the overall frame the result would become as shown in <xref
                        xlink:href="#fig.accbarframeex03"/> below</para>
                <para>
                    <programlisting>#=accbarframeex03|Setting individual frames to weight=0#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Grouped bar plots</title>
                <para>This uses the same principle as accumulated bar plots but instead of stacking
                    the data series on top of each other they are shown together for the same
                    x-value.</para>
                <para>These types of bar graph is used to easy group two or more bars together
                    around each tick (x-value). The bars will be placed immediately beside each
                    other and as a group centered on each tick mark (or between if a text scale is
                    used). A grouped bar is created by aggregating two or more ordinary bar plots
                    and creating a <code>GroupBarPlot</code>
                </para>
                <para>
                    <programlisting>&lt;?php
// Some data
$data1y = ...
$data2y = ...

// Create the bar plots
$b1plot = new  BarPlot ( $data1y );
$b1plot->SetFillColor ( 'orange' );

$b2plot = new  BarPlot ( $data2y );
$b2plot->SetFillColor ( 'blue' );

// Create the grouped bar plot
$gbplot = new  GroupBarPlot (array( $b1plot , $b2plot ));

// Add it to the graph
$graph->Add ( $gbplot ); 
?></programlisting>
                </para>
                <para>An example of this is shown in <xref xlink:href="#fig.example21"/></para>
                <para>
                    <programlisting>#=example21|A grouped bar plot#</programlisting>
                </para>
                <para>If the <code>SetWidth()</code> method is used on the
                        <code>GroupBarPlot()</code> it will affect the total width used by all the
                    added plots. Each individual bar width will be the same for all added bars. The
                    default width for grouped bar is 70% of the width between the tick marks in the
                    graph. In <xref xlink:href="#fig.example22"/> an example where the width is set
                    to 90% is shown.</para>
                <para>
                    <programlisting>#=example22|Adjusting the width of a group bar plot#</programlisting>
                </para>
                <para>The number of data points in each data series must be the same. This means
                    that if there are no available values they should be specified as 0. An example
                    of this is shown in <xref xlink:href="#fig.groupbarex1"/></para>
                <para>
                    <programlisting>#=groupbarex1|All data series in a grouped bar graph must have the same number of data points#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Grouped accumulated bar graphs</title>
                <para>It is perfectly possible to combine the previous bar types to have a grouped
                    accumulated bar plot. This is done in a similar way by aggregating a number of
                    accumulated plots in a group bar plot. The following code snippte shows how this
                    can be done</para>
                <para>
                    <programlisting>&lt;?php
// Create all the 4 bar plots
$b1plot = new  BarPlot( $data1y );
$b1plot->SetFillColor( "orange" );
$b2plot = new  BarPlot( $data2y );
$b2plot->SetFillColor( "blue" );
$b3plot = new  BarPlot( $data3y );
$b3plot->SetFillColor( "green" );
$b4plot = new  BarPlot( $data4y );
$b4plot->SetFillColor( "brown" );

// Create the accumulated bar plots
$ab1plot = new  AccBarPlot(array( $b1plot , $b2plot ));
$ab2plot = new  AccBarPlot(array( $b3plot , $b4plot ));

// Create the grouped bar plot
$gbplot = new  GroupBarPlot(array( $ab1plot , $ab2plot ));

// Add the combination to the graph
$graph->Add( $gbplot ); 
?></programlisting>
                </para>
                <para>An example of this is shown in <xref xlink:href="#fig.example24"/>
                    below</para>
                <para>
                    <programlisting>#=example24|A grouped accumulated bar graph#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Horizontal bar graphs</title>
                <para>If a large number of values to needs to be display in a bar graph it is often
                    better to rotated the bar graph 90 degree so that the bars are horizontal
                    instead. There is no special graph type for this so this is achieved by rotating
                    a standard vertical bar graph 90 degrees, usually with a call to</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>Graph::Set90AndMargin()</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>The orientation of the labels of the axis will be automatically adjusted for
                    bar graphs. A basic example is shown in <xref xlink:href="#fig.horizbarex1"/>
                    below</para>
                <para>
                    <programlisting>#=horizbarex1|A basic horizontal bar graph#</programlisting>
                </para>
                <para>The example in <xref xlink:href="#fig.horizbarex4"/>shows how to use multiple
                    lines as labels. </para>
                <para>
                    <caution>
                        <para>Note that we have to use quotation marks (") and not hyphens (') in
                            text string where we want to embed a newline character, i.e. "\n"</para>
                    </caution>
                </para>
                <para>
                    <programlisting>#=horizbarex4|Using multiple line labels in a horizontal bar graph#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Adjusting the appearance of bar graphs</title>
                <para/>
                <sect3>
                    <title>Adjusting the width and colors</title>
                    <para>The width of each individual bar can be specified in either an absolute
                        pixel size or as a fraction of the width between the major tick marks. The
                        method used for this is</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>BarPlot::SetWidth($aWidth)</code></para>
                                <para>If <code>$aWidth</code> is an integer > 1 then it is
                                    interpretated as an absolute width in pixels. If it is a
                                    floating point number in the range [0,1] it will be
                                    interpretated as a fraction of the width between the tick
                                    marks.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para/>
                </sect3>
                <sect3>
                    <title>Using gradient fill</title>
                    <para>It is possible to use color gradient fill for the individual bars in the
                        bar graph.</para>
                    <para>Color gradient fill fills a rectangle with a smooth transition between two
                        colors. In what direction the transition goes (from left to right, down and
                        up, from the middle and out etc) is determined by the style of the gradient
                        fill. The library currently supports 8 different styles. All supported
                        styles are displayed in <xref xlink:href="#fig.bar-grad-fills"/>
                        below.</para>
                    <para>
                        <figure xml:id="fig.bar-grad-fills">
                            <title>Supported gradient fills for bar plots</title>
                            <informaltable frame="none">
                                <tgroup cols="2">
                                    <colspec colname="c1" colnum="1"/>
                                    <colspec colname="c2" colnum="2"/>
                                    <tbody>
                                        <row>
                                            <entry>
                                                <programlisting>#=bargradsmallex1|GRAD_MIDVER#</programlisting>
                                            </entry>
                                            <entry>
                                                <programlisting>#=bargradsmallex2|GRAD_MIDHOR#</programlisting>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <programlisting>#=bargradsmallex3|GRAD_HOR#</programlisting>
                                            </entry>
                                            <entry>
                                                <programlisting>#=bargradsmallex4|GRAD_VER#</programlisting>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <programlisting>#=bargradsmallex5|GRAD_WIDE_MIDVER#</programlisting>
                                            </entry>
                                            <entry>
                                                <programlisting>#=bargradsmallex6|GRAD_WIDE_MIDHOR#</programlisting>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <programlisting>#=bargradsmallex7|GRAD_CENTER#</programlisting>
                                            </entry>
                                            <entry>
                                                <programlisting>#=bargradsmallex8|GRAD_RAISED_PANEL#</programlisting>
                                            </entry>
                                        </row>
                                    </tbody>
                                </tgroup>
                            </informaltable>
                        </figure>
                    </para>
                    <para>To specify a gradient fill for the bar plots you make use of the method
                            <code>BarPlot::SetFillGradient()</code> . See the class reference for
                        details of this function.</para>
                    <para>
                        <caution>
                            <para>Gradient filling is computational expensive. Large plots with
                                gradient fill will take in the order of 6 times longer to fill then
                                for a normal one-color fill. This might to some extent be helped by
                                making use of the cache feature of JpGraph so that the graph is only
                                generated a few times.</para>
                        </caution>
                    </para>
                    <para> As a final example we show an horizontal bar graph with gradient fill on
                        both the background and the bars in <xref xlink:href="#fig.horizbarex6"/>
                    </para>
                    <para>
                        <programlisting>#=horizbarex6|Horizontal bar graph with gradient fill#</programlisting>
                    </para>
                </sect3>
                <sect3>
                    <title>Using pattern fills</title>
                    <para>As an alternative to solid and gradient fill the bars can also have a
                        number of patterns. This is useful for the case where black and white copies
                        needs to be printed. The library supports the following nine different
                        patterns as shown in <xref xlink:href="#fig.barplot-patterns"/></para>
                    <para>
                        <figure xml:id="fig.barplot-patterns">
                            <title>Supported pattern fills for bar plots</title>
                            <informaltable frame="none">
                                <tgroup cols="3">
                                    <colspec colname="c1" colnum="1"/>
                                    <colspec colname="c2" colnum="2"/>
                                    <colspec colname="c3" colnum="3"/>
                                    <tbody>
                                        <row>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern1.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern2.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern3.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern4.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern5.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern6.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                        </row>
                                        <row>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern7.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern8.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                            <entry>
                                                <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/bar_pattern9.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            </entry>
                                        </row>
                                    </tbody>
                                </tgroup>
                            </informaltable>
                        </figure>
                    </para>
                    <para>To specify a pattern to be used the following method is used</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>BarPlot::SetPattern($aPattern,$aColor='black')</code></para>
                                <para><code>$aPattern</code> is one of the symbolic names as shown
                                    in <xref xlink:href="#fig.barplot-patterns"/> If
                                        <code>$aPattern</code> is an array then each specified
                                    pattern will be used successively for each individual bar. If
                                    there are more bars then pattern specified then pattern used
                                    will be wrapped around.</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </sect3>
                <sect3>
                    <title>Displaying and formatting the value of the bar</title>
                    <para>In the same way as values could be displayed on line plots they can also
                        be displayed on bar graphs. The formatting options for bar graphs, apart
                        from the basic font,color and angle, also allows the specification on where
                        on the bar the values should be displayed. This can be</para>
                    <para><itemizedlist>
                            <listitem>
                                <para>at the bottom of the bar, "<code>bottom</code>"</para>
                            </listitem>
                            <listitem>
                                <para>at the middle of the bar, "<code>middle</code>"</para>
                            </listitem>
                            <listitem>
                                <para>at the maximum value (but still inside the bar).
                                        "<code>max</code>"</para>
                            </listitem>
                            <listitem>
                                <para>at the top of the bar (outside the bar),
                                    "<code>top</code>"</para>
                            </listitem>
                        </itemizedlist>The position is adjusted with a call to</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>BarPlot::SetValuePos($aPos)</code></para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>using one of the above strings as value.</para>
                    <para>The value of the bar is enabled and controlled by accessing the "value"
                        property of the bar plot. The following line will enable the value (this is
                        done in exactly the same way as for line plots)</para>
                    <para>
                        <programlisting>$barplot->value->Show();</programlisting>
                    </para>
                    <para>By default the value is displayed at the top of the bar. In the same way
                        as for line plot it is possible to adjust the formatting of the data labels
                        by both using a format callback function as well as statically adjusting the
                        format, for example the angle of the label.</para>
                    <para>
                        <programlisting>// Callback function
function separator1000_usd($aVal) {
    return '$'.number_format($aVal);
}

// Must use TTF fonts if we want text at an arbitrary angle
$bplot->value->SetFont(FF_ARIAL,FS_BOLD);
$bplot->value->SetAngle(45);
$bplot->value->SetFormatCallback('separator1000_usd');

// Black color for positive values and darkred for negative values
$bplot->value->SetColor('black','darkred');
$graph->Add($bplot);</programlisting>
                    </para>
                    <para>There is one thing to take notice of here. The color of the label can be
                        different depending on whether the bar has a positive or a negative
                        value.</para>
                    <para>An example of using these formatting options for a bar graph is shown in
                            <xref xlink:href="#fig.barscalecallbackex1"/></para>
                    <para>
                        <programlisting>#=barscalecallbackex1|Using a callback to format the labels on a bar#</programlisting>
                    </para>
                </sect3>
                <sect3>
                    <title>Adding a drop shadow to the bars</title>
                    <para>Each bar can also have a drop shadow. This is enabled by calling</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>BarPlot::SetShadow($aColor="black",$aHSize=3,$aVSize=3,$aShow=true)</code></para>
                                <para><code>$aColor</code>, The color of the drop shadow</para>
                                <para><code>$aHSize</code>, Horizontal size of the shadow</para>
                                <para><code>$aVSize</code>, Vertical size of the shadow</para>
                                <para><code>$aShow</code>, <code>true</code> = enable the
                                    shadow</para>
                            </listitem>
                        </itemizedlist>
                    </para>
                </sect3>
            </sect2>
        </sect1>
        <sect1 xml:id="sec1.creating-error-graphs">
            <title>Error plot graphs</title>
            <para>Error plots are used to visually indicate uncertainty in data points. This is done
                by specifying both a min and and max value for each data point.</para>
            <para>Before error plots can be used the module "<filename>jpgraph_error.php</filename>"
                must be included.</para>
            <para>The following example illustrates a simple error bar. We will have 5 points, so we
                need 10 Y-values. We also would like the error bars to be red and 2 pixels wide. All
                this is accomplished by creating an instance of the <code>ErrorPlot</code> class in
                much the same way as, for example, a normal line plot.</para>
            <para>
                <programlisting>#=example13|A basic error plot#</programlisting>
            </para>
            <para>There is one displeasing esthetic quality of this graph. The X-scale is just wide
                enough to just accompany the number of error bars and hence the first bar is drawn
                on the Y-axis and the and last bar just at the edge of the plot area. </para>
            <para>To adjust this we can use the method <code>ErrorPlot::SetCenter()</code> which
                will adjust the x-scale so it does not use the full width of the X-axis.</para>
            <para>
                <programlisting>#=example14|Making use of SetCenter() with error plots#</programlisting>
            </para>
            <para/>
            <sect2>
                <title>Line error plots</title>
                <para>A variant of the error plot graph is to use an <code>LineErrorPlot</code>
                    instead. This is almost the same as the <code>ErrorPlot</code> but with the
                    added feature that each data point also has an middle value which a line is
                    drawn through. This can be thought of as a line plot combined with an error
                    plot.</para>
                <para>Since this also uses a line the module "<filename>jpgraph_line.ph</filename>p"
                    must be included in addition to the error module.</para>
                <para>To control the various properties of the line drawn the "line" property of the
                    error line plot may be accessed. So, for example, to set the line to have weight
                    of 2 pixels wide and with a blue color the following two lines are needed</para>
                <para>
                    <programlisting>&lt;?php
$elplot->line->SetWeight ( 2 );
$elplot->line->SetColor ( 'blue' ); 
?></programlisting>
                </para>
                <para>An example of this is shown in <xref xlink:href="#fig.example15"/>. We could
                    now also add a legend to none, one or both of the line types(the plain line
                    and/or the error bar). So for example if we wanted the legend "Min/Max" for the
                    red error bars and a legend "Average" for the blue line the following lines
                    should be added</para>
                <para>
                    <programlisting>&lt;?php
$errplot->SetLegend ( 'Min/Max' );
$errplot->line->SetLegend ( 'Average' ); 
?></programlisting>
                </para>
                <para>The result is shown in <xref xlink:href="#fig.example16"/></para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=example15|A basic Line error plot#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=example16|A line error plot with a legend#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sect2>
        </sect1>
        <sect1 xml:id="sec1.creating-stock-graphs">
            <title>Stock graphs</title>
            <para>Stock charts are used to display data values where one is interested in 4
                different values for each data point. This could for example be used to display a
                stocks open,close, min and max value during a specific day. Hence the name Stock
                chart (or Stock plot).</para>
            <para>Stock plots are created as an instance of <code>class StockPlot</code> so the
                module "<filename>jpgraph_stock.php</filename>" must first be included in the
                script.</para>
            <para><xref xlink:href="#fig.stockex1"/>illustrates a sample Stock chart plot</para>
            <para>
                <programlisting>#=stockex1|A stock graph#</programlisting>
            </para>
            <para>For this type of plot the y-data array must be consist of a number of quadruples
                of data where each quadruple consists of (open,close,min,max). The open and close
                values determine the min max for the middle bar and the min,max determine the end
                points of the "error-lines" at the top and bottom of each bar as shown in ??.</para>
            <para>
                <informaltable frame="none">
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="0.98*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.02*"/>
                        <tbody>
                            <row>
                                <entry valign="top">
                                    <figure xml:id="fig.details-stock-chart">
                                        <title>Explaining stock graphs</title>
                                        <para>
                                            <inlinemediaobject><imageobject><imagedata scale="60"
                                                  fileref="images/stock-detail-explanation.png"
                                                  /></imageobject></inlinemediaobject>
                                        </para>
                                    </figure>
                                </entry>
                                <entry valign="top">
                                    <para>For this type of plot the y-data array must be consist of
                                        a number of quadruples of data where each quadruple consists
                                        of an even number of (open,close,min,max). </para>
                                    <para>The open and close values determine the min max for the
                                        middle bar and the min,max determine the end points of the
                                        "error-lines" at the top and bottom of each bar as shown in
                                            <xref xlink:href="#fig.details-stock-chart"/>.</para>
                                    <para>Note that the data follows the rules</para>
                                    <para>
                                        <itemizedlist>
                                            <listitem>
                                                <para>min &lt; max</para>
                                            </listitem>
                                            <listitem>
                                                <para>min &lt; min( open, close )</para>
                                            </listitem>
                                            <listitem>
                                                <para>max > max( open, close )</para>
                                            </listitem>
                                        </itemizedlist>
                                    </para>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>To separate the two cases where "open > close" or "open &lt; close " two different
                colors are used. </para>
            <para>These colors are specified with the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>StockPlot::SetColor($aFrame, $aFill='white',
                                $aFrameNeg='darkred', $aFillNeg='darkred')</code></para>
                        <para><code>$aFrame</code>, <code>$aFill</code>, The frame and fill color
                            when open &lt;= close</para>
                        <para><code>$aFrameNeg</code>, <code>$aFillNeg</code>, The frame and fill
                            color when open > close</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para><code>StockPlot::SetColor()</code> method. By default a positive bar (close >
                open) have a fill color of white and for the negative case where (close &lt; open)
                the bars have a red color.</para>
            <para>The final possible variation of stock plots is the option to determine whether or
                not the end point for the min,max lines should have the horizontal line marking the
                end of the line or not. This can be adjusted with a call to method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>StockPlot::HideEndLines($aHide=true)</code></para>
                    </listitem>
                </itemizedlist>
            </para>
            <sect2>
                <title>Stock plot variant: Boxplot</title>
                <para>A minor variation of stock charts is the <code>BoxPlot</code> plot type. this
                    is almost the same as <code>StockPlot</code> but with the very small difference
                    that in addition to the open,close,min, max values it is also possible to
                    specify a fifth, median value . </para>
                <para>A box plot is created as in instance of <code>class BoxPlot</code> which is
                    defined in "<filename>jpgraph_stock.php</filename>"</para>
                <para>The median lies between the open and close value and is illustrated as a
                    horizontal line within the bar. An example of this is shown in </para>
                <para>
                    <programlisting>#=boxstockex1|A typical boxplot#</programlisting>
                </para>
                <para>The color of the median line can be modified with a call to </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>BoxPlot::SetMedianColor($aColor)</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect2>
            <sect2>
                <title> Image maps for Box and Stock charts</title>
                <para>In the same way as for other plots it is possible to associate an image map
                    with these plots. The "hot" area for each plot is the mid "bar" section. In the
                    same way as other plot types the method </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>BoxPlot::SetCSIMTargets($aTargets,$aAlts='',$aWinTargets='')</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>is used to set the URL:s for the hot areas</para>
            </sect2>
        </sect1>
        <sect1 xml:id="sec1.creating-scatter-graphs">
            <title>Scatter graphs</title>
            <para>Scatter plots are used to display a number of data points given by there x- and
                y-coordinate. The difference from a line plot is that the x-coordinate must always
                be specified. Each point is stroked on the image with a mark as with line plots. The
                stroked marks can also be connected with an optional line.</para>
            <para>To use a scatter plot the module "<filename>jpgraph_scatter.php</filename>" must
                first be included in the script.</para>
            <para>
                <note>
                    <para>Carefully reviewing the constructor for line plots shows that it also can
                        accept both a x- and y-array with coordinates. This means that a line plot
                        can also be used to create a scatter plot. However scatter plots have some
                        formatting options not available for line plots.</para>
                </note>
            </para>
            <para>Even though the normal use of scatter plots is to supply both x- and y-coordinates
                it is still perfectly possible to use a text- or int-scale for the x-coordinates to
                just enumerate the points (the points will be placed along an imaginary integer
                scale). This is especially useful when using the "Impulse" type of scatter plot as
                shown below.</para>
            <para>If no x-coordinates are specified each value will be placed at consecutive
                x-coordinates [<code>1,2,3,..</code>] </para>
            <para>A scatter plot is constructed by creating an instance of the <code>class
                    ScatterPlot</code> supplied with the proper arguments, i.e.</para>
            <para>
                <programlisting>$scatterplot = new ScatterPlot($ydata, $xdata);</programlisting>
            </para>
            <para>The following example shows a very basic scatter plot</para>
            <para>
                <programlisting>#scatterex1|A basic scatter plot#</programlisting>
            </para>
            <para>In the same way as we adjusted the look and feel for markers for line plot (see
                ??) we can do the same here as shown in <xref xlink:href="#fig.scatterex2"/></para>
            <para>
                <programlisting>#=scatterex2|Adjusting the size and color of the marker#</programlisting>
            </para>
            <para>The marks are accessed through the instance variable
                    <code>ScatterPlot::mark</code> (in complete analogy with line plots)</para>
            <sect2>
                <title>Combining marks with a line</title>
                <para>It is possible to combine the individual data points with a line - a link. The
                    properties for this link can be accessed by using the instance variable
                        <code>ScatterPlot::link</code>.In order to enable the link the method
                        <code>ScatterPlot::link::Show()</code> must first be called.</para>
                <para>
                    <note>
                        <para>For historical reasons there is also a utility method
                            ScatterPlot::SetLinkPoints() where links can be enabled and adjusted.
                            However, this method will be removed in future versions of the
                            library.</para>
                    </note>
                </para>
                <para>The properties that can be adjusted are the normal line properties, i.e.
                    weight, color and line style. The following code snippet shows how to add a link
                    line with a dotted style drawn in black to scatter plot.</para>
                <para>
                    <programlisting>&lt;?php
// Enable the link lines
$scatterplot->link->Show();

// Set the properties
$scatterplot->link->SetWeigth(1);
$scatterplot->link->SetColor('black');
$scatterplot->link->SetStyle('dotted');
?></programlisting>
                </para>
                <para>In <xref xlink:href="#fig.scatterlinkex3"/> and <xref
                        xlink:href="#fig.scatterlinkex4"/> there are two variants of adding a link
                    line to a scatter plot. For those figures we have also used two of the
                    predefined scientific axis styles (see <xref
                        xlink:href="#sec2.predef-axis-setup"/>).</para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=scatterlinkex3|Combining data points with a dotted line#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=scatterlinkex4|Combining data points with a red line#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sect2>
            <sect2>
                <title>Creating impulse (or stem) - plots</title>
                <para>A variant of scatter plots often used electrical engineering is the stem plot
                    as shown in <xref xlink:href="#fig.barplot-patterns"/></para>
                <para>
                    <programlisting>#=impulsex1|Stem plot#</programlisting>
                </para>
                <para>This variant of the scatter plot is created by calling the method</para>
                <para>
                    <programlisting>$scatterplot->SetStem();</programlisting>
                </para>
                <para><tip>
                        <para>It is possible to create a stem graphs without any mark by specifying
                            the mark type as (-1) . That way only the impulse lines will be
                            drawn.</para>
                    </tip>In order to adjust the look and feel of the stems the following methods
                    can be used</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>ScatterPlot::SetWeight($aWeight)</code></para>
                        </listitem>
                        <listitem>
                            <para><code>ScatterPlot::SetColor($aColor)</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>Another example of stem plot is shown in <xref xlink:href="#fig.impulsex3"/>
                    where we have adjusted both the look and feel of the stem plot as well as the
                    position of the x-axis.</para>
                <para>
                    <programlisting>#=impulsex3|Adjusting the overall look and feel for the stem graph#</programlisting>
                </para>
                <para>There is also another complex impulse example shown in <xref
                        xlink:href="#fig.impulsex4"/> where we have used a <code>PlotLine</code> to
                    create a "virtual" x-axis.</para>
            </sect2>
            <sect2 xml:id="sec1.creating-field-graphs">
                <title>Field plots</title>
                <para>A variant of scatter plot is the so called Field Plots. </para>
                <para>This is basically a scatter plot where each scatter point is an arrow with a
                    direction between 0 to 359 degrees. This effectively allows the visualization of
                    3 parameters at each point (x,y and angle). </para>
                <para>A field plot is created as an instance of <code>class FieldPlot</code> with
                    three argument</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>an array of y-coordinates</para>
                        </listitem>
                        <listitem>
                            <para>an array of x-coordinates</para>
                        </listitem>
                        <listitem>
                            <para>an array of angles</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>as the following code snippet shows</para>
                <para>
                    <programlisting>$fieldplot = new FieldPlot($datay, $datax, $angle);</programlisting>
                </para>
                <para>The size and color of each arrow in the field plot is controlled by accessing
                    the property <code>FieldPlot::arrow</code> and using the two methods</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>FieldPlot::arrow->SetSize($aSize,$aArrowSize=2)</code></para>
                            <para><code>$aSize</code>, Specifies the length (in pixels) of the
                                arrow</para>
                            <para><code>$aArrowSize</code>, The arrow size is specified as an
                                integer in the range [0,9]. The possible arrow sizes are shown in
                                    <xref xlink:href="#fig.field-arrow-sizes"/>.</para>
                            <para>
                                <figure xml:id="fig.field-arrow-sizes">
                                    <title>Possible sizes of arrow heads for field plots</title>
                                    <mediaobject>
                                        <imageobject><imagedata scale="60"
                                                fileref="images/field_arrow_sizes.png"
                                            /></imageobject>
                                    </mediaobject>
                                </figure>
                            </para>
                        </listitem>
                        <listitem>
                            <para><code>FieldPlot::arrow->SetColor($aColor)</code></para>
                            <para>The color of the arrow</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>Another way to individually format each arrow is to use a callback method. The
                    callback method must have three arguments x- , y-coordinates and angle. The
                    callback method must return an array with three elements (color,size,arrow
                    size). The callback method is specified by calling</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>FieldPlot::SetCallback($aFunc)</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para><xref xlink:href="#fig.fieldscatterex1"/> shows a field plot with a callback
                    function.</para>
                <para>
                    <programlisting>#=fieldscatterex1|A field plot#</programlisting>
                </para>
            </sect2>
            <sect2 xml:id="sec1.creating-balloon-graphs">
                <title>Balloon plots</title>
                <para>This is a variant of scatter plot where each data point is a filled circle and
                    the size of the circle is dynamically adjusted. This makes it possible to
                    display three values at each data point (x,y,"size"). There is no need for a
                    specific plot type for this since these types of plots can be constructed with
                    an ordinary scatter plot and a mark formatting callback.</para>
                <para>In order to specify a callback for the marks the following method is
                    used</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>ScatterPlot::mark::SetCallbackYX($aFunction)</code></para>
                            <para>The argument for the callback function is y- and x-value for the
                                data point. The return value should specify the format of the marker
                                as an array of <emphasis role="italic">(width, border_color,
                                    fill_color, filename, image scale)</emphasis>. All values must
                                be included.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>We can now create a balloon plot as follows. </para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>Create a data array that specifies the data including both x- and
                                y-coordinate, color and size of the filled circle. For example
                                as:</para>
                            <para>
                                <programlisting>$data = array(
    array(1,12,10,'orange'),
    array(3,41,15,'red'),
    array(4,5,19,'lightblue'),
    array(5,70,22,'yellow')
);</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>We must now convert this to some suitable data for a scatter plot.
                                The only thing to keep in mind is that we need to share the data
                                with the callback function and for that purpose we store the
                                formatting data in an external array indexed by the x,y-value. </para>
                            <para>
                                <programlisting>$n = count($data);
for( $i=0; $i &lt; $n; ++$i ) {
    
    $datax[$i] = $data[$i][0];
    $datay[$i] = $data[$i][1];

    
    $format[ strval($datax[$i]) ][ strval($datay[$i]) ] = array( $data[$i][2], $data[$i][3] );
    
}</programlisting>
                            </para>
                            <para>The callback function can now be specified as</para>
                            <para>
                                <programlisting>function FCallback($aYVal,$aXVal) {
    // We need to access the global format array
    global $format;
    return array($format[ strval($aXVal) ][ strval($aYVal) ][0],'',
                 $format[ strval($aXVal) ][ strval($aYVal) ][1],'','');
}</programlisting>
                            </para>
                            <para>The callback function will now return the format value (size and
                                color) we specified originally depending on the x,y - coordinate.
                                The callback function can be installed with a call to</para>
                            <para>
                                <programlisting>$sp1->mark->SetCallbackYX('FCallback');</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>The final step is to create an ordinary scatter plot with a marker
                                that is specified as a filled circle</para>
                            <para>
                                <programlisting>$sp1 = new ScatterPlot($datay,$datax);
$sp1->mark->SetType(MARK_FILLEDCIRCLE);</programlisting>
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>As an optional additions we can also enable the display of the values at each
                    data point by calling</para>
                <para>
                    <programlisting>$sp1->value->Show();
$sp1->value->SetFont(FF_FONT1,FS_BOLD);</programlisting>
                </para>
                <para>Putting all these together gives the result shown in <xref
                        xlink:href="#fig.balloonex2"/></para>
                <para>
                    <programlisting>#=balloonex2|Using format callback to create a balloon plot#</programlisting>
                </para>
            </sect2>
            <sect2 xml:id="sec1.creating-geo-maps">
                <title>Creating Geo-maps</title>
                <para>Geo-maps (a.k.a. Geo-charts, push-pin graphs) is used to illustrate locations
                    around the world by putting markers on a flat projection of the earth. A Geo-map
                    is done by adding a Worldmap background to a standard scatter graph. The library
                    includes a suitable background in the "<filename>Examples/</filename>" directory
                        "<filename>wordmap1.jpg</filename>". This can then be done as the following
                    example shows</para>
                <para>
                    <programlisting>#pushpinex1|An example with geo maps#</programlisting>
                </para>
                <para>Another example of using worldmaps with Pie graphs is shown in <xref
                        xlink:href="#sec.pie-image-background"/></para>
                <para>
                    <note>
                        <para>The library does not include any conversion utility to/from
                            Longitude/Latitude to UTM coordinates that could be used to
                            automatically position data marks on the Mercator projection map. The
                            options to stretch and scale the worldmap would make it rather
                            cumbersome to create a accurate conversion. For a good overview on this
                            kind of translation see <uri
                                xlink:href="http://www.gpsy.com/gpsinfo/geotoutm/">Converting
                                Latitude/Longitude to Universal Transverse Mercator
                            (UTM)</uri></para>
                    </note>
                </para>
            </sect2>
        </sect1>
        <sect1 xml:id="sec.contour-graphs">
            <title>Contour graphs </title>
            <para>In order to create Radar graphs the module
                    "<filename>jpgraph_contour.php</filename>" must first be included.</para>
            <para>
                <note>
                    <para> The Pro-version (>= v3.1) also includes a module
                            "<filename>jpgraph_contourf.php</filename>" which is also supports
                        filled contour plots as well as labelling in the plots of the isobar lines.
                        The pro-version also uses a more advanced adaptive-mesh algorithm that give
                        better resolution without manual interpolation of the original data. Both
                        triangular and rectangular interpolation meshes are supported. The filled
                        contour is described in <xref xlink:href="#chapter.filled-contour-graphs"/>
                    </para>
                </note>
            </para>
            <para>Contour plots are used to plot the isobar lines (height curves) of a three
                dimensional (3D) graph. The contour plot itself is only a two-dimensional plot and
                looks like an ordinary topographic map. An example of a contour graph is shown in
                    <xref xlink:href="#fig.basic_contourex01"/></para>
            <para>
                <programlisting>#=basic_contourex01|A basic contour graph#</programlisting>
            </para>
            <para>A contour graph is both similar and different from other types x-y graphs.</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>A contour graph uses the standard x-y <code>class Graph</code> as
                            basic graph canvas</para>
                    </listitem>
                    <listitem>
                        <para>A contour graph has all the standard graph formatting options</para>
                    </listitem>
                    <listitem>
                        <para>The legend is automatically generated</para>
                    </listitem>
                    <listitem>
                        <para>The input data is a matrix and not an array</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>There are primarily four main parameters that can be used to control the apparency
                of the contour plots</para>
            <para>
                <orderedlist>
                    <listitem>
                        <para><emphasis role="bold">the number of isobar lines</emphasis>, by
                            default 10 isobar lines are used</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">the level of data grid interpolating,</emphasis>
                            i.e. to give the appearance of smoother isobar lines it is possible to
                            tell the library to create a number of intermediate points between the
                            given points in the input data matrix. It is important to note that this
                            does not create any further real information it only creates smoother
                            lines under the assumption that it is valid to assume linear
                            interpolation between the original data points. </para>
                        <para>The level of interpolation is specified as an integer in the practical
                            range 1 to 5. A level of 1 corresponds to just keeping the original
                            data, a level of 2 corresponds to subdividing the original data points
                            in two, i.e. one extra interpolated points is created in both x- and
                            y-direction and so on. A level of 3 corresponds to further sub-divding
                            the level 2 matrix one more time. </para>
                        <para>Even though it is theoretically possible to use an arbitrary
                            interpolation factor the library does not allow an interpolation factor
                            larger than 5. The reason is purely computational since the total number
                            of data points increases very quickly.</para>
                        <para>For example if the original grid has size 10x10 (=100 data points)
                            interpolating this grid with a factor of 5 will generate a new matrix of
                            size 145x145 (=21025 data points).</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">flip around the Y-axis</emphasis>. By default
                            the first row in the input matrix corresponds to y=0, however this also
                            means that the plotted contour will be flipped compared with the input
                            matrix since y=0 is at the bottom of the graph. If for visual appearance
                            reason one wants the input data matrix to have the same orientation as
                            the resulting graph it is possible to have the library interpret the
                            last row in the input data matrix as y=0 instead</para>
                    </listitem>
                    <listitem>
                        <para><emphasis role="bold">the color of the isobar lines</emphasis>. By
                            default they will be assigned from the natural color spectra with pure
                            dark blue corresponding to the lowest point in the plot and pure red
                            corresponding to the highest isobar.</para>
                    </listitem>
                </orderedlist>
            </para>
            <para>The remaining possibilities to adjust the appearance of the contour plot
                corresponds to the standard ways of changing the layout of the graph, for example
                adding titles, adjusting colors and changing the type of axis to be
                displayed.</para>
            <para>The scale of the contour plot is by default the natural scale, i.e. the points are
                assumed to be numbered (0..n) where n is the number of points in the corresponding
                direction and also corresponds to each entry in the input data matrix.</para>
            <sect2>
                <title>Input data for contour graphs</title>
                <para>The input data to a contour graph is a matrix. The value at each entry in the
                    matrix represents the heights at the specified (row,col) in the matrix. In all
                    of our example we will use the following data matrix</para>
                <para>
                    <programlisting>&lt;?php
$data = array(
            array (0.5,1.1,1.5,1,2.0,3,3,2,1,0.1),
            array (1.0,1.5,3.0,5,6.0,2,1,1.2,1,4),
            array (0.9,2.0,2.1,3,6.0,7,3,2,1,1.4),
            array (1.0,1.5,3.0,4,6.0,5,2,1.5,1,2),
            array (0.8,2.0,3.0,3,4.0,4,3,2.4,2,3),
            array (0.6,1.1,1.5,1,4.0,3.5,3,2,3,4),
            array (1.0,1.5,3.0,5,6.0,2,1,1.2,2.7,4),
            array (0.8,2.0,3.0,3,5.5,6,3,2,1,1.4),
            array (1.0,1.5,3.0,4,6.0,5,2,1,0.5,0.2));
?></programlisting>
                </para>
                <para>By default the entry (0,0), i.e. row=0, col=0 will be positioned at graph
                    position (0,0), i.e. the lower left corner. Since this will represent an
                    inverted image compare to the data matrix. In order to have the graph oriented
                    in the same way as the data matrix, i.e. entry (0,0) positioned in the top left
                    corner the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>ContourPlot::SetInvert($aFlg=true)</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>In order to get a smooth contour plot it is necessary to have adequate number
                    of data points. What consists "adequate" number depends on the overall graph
                    size. The larger graph the more points are needed. To help crate smooth contour
                    plot the library offers automatic linear interpolation to specified depth. It is
                    important to note that this does not increase the accuracy. It merely creates
                    artificial point to draw smoother curves. This technique is described in detail
                    in <xref xlink:href="#sec.grid-interpolating"/></para>
                <tip>
                    <para>If the data for the matrix is available in a file a convinient way to get
                        hold of the dat in the file is to use the utility <code>class
                            ReadFileData</code> to get hold of the data using the method<code>
                            ReadFileData::FromMatrix($aFile,$aSeparator=' ')</code> which read the
                        matrix from a file. Each row of the matrix must be a separate line and each
                        cell is separated with the character specified as the second argument. By
                        default a space is used as separator. All values read back are converted to
                        floating point numbers (double precision). The following short example shows
                        how easy this is to use</para>
                    <para>
                        <programlisting>$data = ReadFileData::FromMatrix('matrixdata.txt');</programlisting>
                    </para>
                </tip>
            </sect2>
            <sect2 xml:id="sec.creating-contour-graph">
                <title>Creating a contour graph</title>
                <para><xref xlink:href="#fig.basic_contourex01"/> shows the most basic contour plot.
                    This is crated by first instantiating a graph and then creating an instance of
                        <code>class ContourPlot</code> which is added to the graph. </para>
                <para>The constructor for <code>class ContourPlot</code> has the following
                    signature</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>ContourPlot::__construct($aDataMatrix, $aIsobar=10,
                                    $aFactor=1, $aInvert=false,
                                $aIsobarColors=array())</code></para>
                            <para><code>$aDataMatrix</code>, The input data</para>
                            <para><code>$aIsobar</code>, The number of isobars if the argument is an
                                integer or an array specifying the exact locations of each isobar if
                                the argument is an array</para>
                            <para><code>$aFactor</code>, Grid interpolation factor</para>
                            <para><code>$aInvert</code>, Invert the data matrix so the matrix entry
                                (0,0) corresponds to the top left corner</para>
                            <para><code>$aIsobarColors</code>, Optional specification of isobar
                                colors </para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>This means that the common structure to create a basic contour plot will
                    be</para>
                <para>
                    <programlisting>&lt;?php
$data = array ( array ( ... ) );

// Basic contour graph
$graph = new Graph($width,$height);
$graph->SetScale('intint');

// Adjust the margins to fit the margin
$graph->SetMargin(30,100,40,30);

// Setup
$graph->title->Set('Basic contour plot');
$graph->title->SetFont(FF_ARIAL,FS_BOLD,12);

// A simple contour plot with default arguments (e.g. 10 isobar lines)
$cp = new ContourPlot($data);

// Display the legend
$cp->ShowLegend();

$graph->Add($cp);
?></programlisting>
                </para>
                <para>Since the most common format for contour graphs is to show axis on all sides
                    we should add the line</para>
                <para>
                    <programlisting>$graph->SetAxisStyle(AXSTYLE_BOXOUT);</programlisting>
                </para>
                <para>to our previous example so we get the effect shown in <xref
                        xlink:href="#fig.basic_contourex02"/>. To show the effect of flipping the
                    data around the center line we have to add the following line</para>
                <para>
                    <programlisting>$cp->SetInvert();</programlisting>
                </para>
                <para>and get the result of adding this line is shown in <xref
                        xlink:href="#fig.basic_contourex05"/></para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=basic_contourex02|Adding axis on all sides#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=basic_contourex05|Flipping the data around the center line#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sect2>
            <sect2>
                <title>Adjusting the color and number of isobar lines</title>
                <para>As mentioned above the library uses 10 isobar lines by default. The number of
                    isobar lines can be adjusted by specifying a second integer argument to the
                    constructor of the contour plot. For example to use only 5 isobar lines the
                    construction of the contour plot would be changed to</para>
                <para>
                    <programlisting>$contourplot = new ContourPlot($data,5);</programlisting>
                </para>
                <para>The result of changing this in the previous example is shown in <xref
                        xlink:href="#fig.basic_contourex04"/></para>
                <para>
                    <programlisting>#=basic_contourex04|Using only 5 isobar lines#</programlisting>
                </para>
                <para>The values for the isobars are determined by finding the lowest and highest
                    point in the input data matrix and then spreading the isobars evenly between
                    these extreme points. </para>
                <para>In some applications however it is necessary to have better control over where
                    exactly the isobars are placed and for this reason it is possible to tell the
                    library exactly at what values the isobars should be. </para>
                <para>This is done by providing an array with the values of the isobars instead of a
                    single number in the creation of the contour plot as the following example
                    shows</para>
                <para>
                    <programlisting>&lt;?php
$isoBars = array( 0.1,  0.2,  0.3,  0.4,  0.5,  0.6 )
$cp = new ContourPlot($data, $isoBars); 
?></programlisting>
                </para>
                <para>The isobar colors can be adjusted by specifying a color array that specifies
                    the color for each isobar.</para>
                <para>However, there is some simpler changes that ca be made to change the colors
                    without having to go through the "trouble" of s√•specifying a color array. </para>
                <para>There are usually two reasons for changing the default color spectra. </para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>to use more high contrast colors</para>
                        </listitem>
                        <listitem>
                            <para>to use only black and white colors</para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>This can be accomplished with a call to the method </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>ContourPlot::UseHighContrastColor($aFlg=true,$aBW=false)
                                </code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>as the following example shows</para>
                <para>
                    <programlisting>$cp = new  ContourPlot( $data );
$cp->UseHighContrastColor( true ); </programlisting>
                </para>
                <para>The above example will only use a blue to red color scale and avoid the
                    "low-contrast" greenish middle color spectrum colors.</para>
                <para>By also setting the second argument to the high contrast method to true the
                    colors are restricted to only black and white. This will of course make it
                    impossible to exactly know the value each isobar represents but could be useful
                    for gaining some insight in the topography of a graph and would allow better
                    printing on black and white devices.</para>
                <para>Specifying manual colors of the isobar can be done in two ways. </para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>By specifying the color array as the fifth argument to the
                                constructor of ContourPlot as shown in <xref
                                    xlink:href="#sec.creating-contour-graph"/></para>
                        </listitem>
                        <listitem>
                            <para>By using the method
                                    <code>ContourPlot::SetIsobarColors($aColors)</code></para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>
                    <caution>
                        <para>The number of colors specified must match the number of
                            isobars.</para>
                    </caution>
                </para>
            </sect2>
            <sect2 xml:id="sec.grid-interpolating">
                <title>Understanding mesh interpolation</title>
                <para>As mentioned above it is possible to use mesh interpolation to generate
                    smoother contour graphs. In order to better understand the effect of specifying
                    different interpolation factors we will show how what effect this have.</para>
                <para>The data we will be using is given by the following data matrix</para>
                <para>
                    <programlisting>$data = array(
            array ( 12,7,3,15 ),
            array ( 18,5,1, 9 ),
            array ( 13,9,5,12),
            array (  5,3,8, 9 ),
            array (  1,8,5, 7 ));</programlisting>
                </para>
                <para>A basic contour graph using the above data is shown in <xref
                        xlink:href="#fig.basic_contourex03-1"/></para>
                <para>
                    <programlisting>#=basic_contourex03-1|Interpolation factor=1#</programlisting>
                </para>
                <para>In order to specify a grid interpolation factor we need to specify this as the
                    third argument in the constructor for the contour plot. So in order to specify a
                    interpolation factor of 2 we would add the line</para>
                <para>
                    <programlisting>$contourplot = new ContourPlot($data,10,3);</programlisting>
                </para>
                <para>To see the difference between different interpolation factor <xref
                        xlink:href="#fig.basic_contourex03-2"/> and <xref
                        xlink:href="#fig.basic_contourex03-3"/> shows the effect of using both a
                    grid interpolation factor of 2 and 3 on the example in <xref
                        xlink:href="#fig.basic_contourex03-1"/></para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=basic_contourex03-2|Interpolation factor=2#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=basic_contourex03-3|Interpolation factor=3#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para>We can now make two observations based on the above two figures</para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>The lines get smoother the higher interpolation factor we
                                use</para>
                        </listitem>
                        <listitem>
                            <para>The automatic scale has changed. This is not surprising since we
                                have in effect increase the number of data points each time we
                                increase the interpolation factor. The scale corresponds to the
                                matrix size (an entry in matrix at position (r,c) corresponds to the
                                point (x=c,y=r) in the graph.)</para>
                            <para>Initially we had a data matrix of size 5x4=20 data points, after
                                doing one interpolation (factor=2) the data matrix will have a size
                                of 9x7=63 data points and after doing one more interpolation
                                (factor=3) the data matrix will have a size of 17x13=221 data
                                points. </para>
                            <para>If we would have done one more interpolation we would have a data
                                matrix of size 33x25=825 data points.</para>
                            <para>The exponential growth of the total number of data point for a
                                10x10 matrix is shown in <xref
                                    xlink:href="#fig.interpolation-growth"/>. This also makes a good
                                example of using a logarithmic y-scale. If the graph is a straight
                                line when plotted against a logarithmic scale this confirms our
                                suspicion that this is indeed a exponentially growing function.
                                    <xref xlink:href="#fig.interpolation-growth-log"/> shows a
                                variant with a logarithmic y-scale (which confirms our
                                suspicion.)</para>
                        </listitem>
                    </orderedlist>
                </para>
                <tip>
                    <para>The helper class to do the actual interpolation can also be used directly
                        in other context. In order to create a new interpolated data matrix with a
                        specific interpolation factor the following code snippet can be used.</para>
                    <para>
                        <programlisting>&lt;?php
$dataMatrix = array( ... );
$factor = ... ;
$grid_interpolate = new Interpolate();
$dataMatrix = $grid_interpolate->Linear($dataMatrix, $factor);
?></programlisting>
                    </para>
                </tip>
                <para>
                    <tip>
                        <para>There is also a utility function
                                <code>doMeshInterpolate(&amp;$aData,$aFactor)</code> that can be
                            sued to interpolate a matrix in place. This creates the necessary class,
                            interpolates its first argument and then fills the argument with the
                            interpolated data. By using call by reference some data copying is
                            avoided.</para>
                    </tip>
                </para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=interpolation-growth|The exponential growth of the data size due to grid interpolation factor#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=interpolation-growth-log|The exponential growth of the data size due to the grid interpolation factor (log scale)#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sect2>
        </sect1>
        <sect1>
            <title>Combining several different plot types in the same graph</title>
            <para>It is perfectly legal to add several different plot types to the same graph. For
                example to mix a line plot with a filled area plot. The different plots will be
                stroked to the graph in the order they are added. This means that the plot (data
                series) that should always be visible should be added last. In the example with the
                filled area and a line the line should probably be added last since it otherwise
                most likely will be overwritten by the filled area plot.</para>
            <para>In <xref xlink:href="#fig.example16.1"/> a basic example is shown where we have
                combined a line plot with an area plot.</para>
            <para>
                <programlisting>#=example16.1|Mixing a line and area plot in the same graph#</programlisting>
            </para>
            <para>As can be seen from looking at the source to the example in <xref
                    xlink:href="#fig.example16.1"/> there is nothing special in doing this other
                then to remember to include all necessary header files. So to add and mix scatter,
                line, error and stock graphs are pretty straightforward.</para>
            <para>However, when it comes to mixing bar plots and lines (or area plot) there is a
                complication. By default bar plots are centered <emphasis role="italic"
                    >between</emphasis> the tick marks since this is the standard way of displaying
                bar graphs since they normally have no specific x-scale. The bars are just in an
                ordered sequence.</para>
            <para>Let's just see what happens if we create a basic bar with a text scale on the
                x-axis and then also add a line plot to the same graph.</para>
            <para>
                <programlisting>#=example16.3|Mixing a line and bar plot in the same graph#</programlisting>
            </para>
            <para>As can be seen from <xref xlink:href="#fig.example16.3"/> the line is adjusted so
                that each data point on the line coincides with the left edge of the barplot and the
                bars are still positoined in the middle of the tick marks as could be expected. This
                is the default behavior when combining a barplot with one of the other linear
                plots.</para>
            <para>If we instead wanted the line to be centered in the barplot (when using a text
                scale) we would have to tell the line plot to position itself in the middle of the
                bars with the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>LinePlot::SetBarCenter()</code></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>Using this method would then give the result shown in <xref
                    xlink:href="#fig.linebarcentex1"/> below</para>
            <para>
                <programlisting>#=linebarcentex1|Centering the line plot in the middle of the bar#</programlisting>
            </para>
            <para>Please note that the above discussion is only valid when using a text scale. if we
                instead would use (for example) an integer scale then both the bar and the line
                would be positioned at the exact scale values (i.e. both bars and lines would be
                left aligned) as can be seen in <xref xlink:href="#fig.example16.4"/></para>
            <para>
                <programlisting>#=example16.4|Mixing bar and line using an integer x-scale#</programlisting>
            </para>
            <para>
                <note>
                    <para>As can be seen in <xref xlink:href="#fig.example16.4"/> it is possible to
                        manually set the scale labels even if we use a linear scale like an integer
                        scale. We only have to keep in mind that we ned to supply labels for all the
                        scale labels and not just the one that are shown in case the scale is fro
                        example only displaying a label on every second tick.</para>
                </note>
            </para>
            <para>An example on how to combine a scatter plot and a line plot is shown in <xref
                    xlink:href="#sec.linear-regression-analysis"/> where a linear regression
                analysis is done.</para>
        </sect1>
        <sect1>
            <title>Creating several graphs in the same image</title>
            <para>There are at least two reasons why one or several graphs should be combined into
                the same image.</para>
            <para><itemizedlist>
                    <listitem>
                        <para>To be able to create overall graphs that are strongly connected and
                            cannot be separated</para>
                    </listitem>
                    <listitem>
                        <para>To reduce the download time by only have to download one image for
                            several graphs</para>
                    </listitem>
                    <listitem>
                        <para>By convention, some types of graphs are always combined</para>
                    </listitem>
                </itemizedlist>The library provides a convenience class , <code>class MGraph</code>
                (for Multi Graph) that assists with this. In order to use this class the module file
                    "<filename>jpgraph_mgraph.php</filename>" must be included.</para>
            <para><xref xlink:href="#fig.combgraphex1"/> shows an example of how this can be
                used.</para>
            <para>
                <programlisting>#=combgraphex1|A combination of a line graph at top and a bar graph in the bottom#</programlisting>
            </para>
            <sect2>
                <title>Creating a combined graph</title>
                <para>In order to better understand what is involved in creating a combined graph we
                    will first show how this is done manually.</para>
                <para>This is done by creating some PHP/GD code that creates a big enough empty
                    image with plain GD commands and then get the image handles from the graphs that
                    should be combined. The image handel can be returned from the
                        <code>Graph::Stroke()</code> methods in the graphs that should be included.
                    It is then possible to use these handles together with the GD image copy command
                    and copy the individual graph images onto the previously created empty large GD
                    image.</para>
                <para>The following (almost complete) code shows how this can be done</para>
                <para>
                    <programlisting>&lt;?php
// Assume we would like to combine graph1,2 and 3
// ...... create graph 1 here.......
$handle1 =  $graph1->Stroke( _IMG_HANDLER);
 
// ...... create graph 2 here.......
$handle2 =  $graph2->Stroke( _IMG_HANDLER);

// ...... create graph 3 here.......
$handle3 =  $graph3->Stroke( _IMG_HANDLER);
 
 
// Now create the "melting graph" which should contain all three graphs
// $WIDTH1 and $HEIGHT1 are width and height of graph 1 ($handle1)
// $WIDTH2 and $HEIGHT2 are width and height of graph 2 ($handle2)
// $WIDTH3 and $HEIGHT3 are width and height of graph 3 ($handle3)
// $x2,$x3 and $y2,$y3 shift from top left of global graph (ie position of 
// graph2 and graph3 in global graph)

$image = imagecreatetruecolor($WIDTH1,$HEIGHT1);
imagecopy($image, $handle1,0, 0, 0, 0, $WIDTH1,$HEIGHT1);
imagecopy($image, $handle2,$x1,$y1,0,0,$WIDTH2,$HEIGHT2);
imagecopy($image, $handle3,$x2,$y2,0,0,$WIDTH3,$HEIGHT3);
 
// Stream the result back as a PNG image
header("Content-type: image/png");
imagepng ($image);
?></programlisting>
                </para>
                <para>The advantages with this fully manual method are </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>Absolute full control on a pixel level how the graphs are
                                combined</para>
                        </listitem>
                        <listitem>
                            <para>Full transparency on how the combination is done</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>but on the other hand the disadvantages are</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>Requires knowledge of the GD library</para>
                        </listitem>
                        <listitem>
                            <para>Requires re-inventing the wheel (since a lot of functionality to
                                manipulate the GD library is already available in the JpGraph
                                library)</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>It is here the <code>class MGraph</code> comes in. It will allow you to very
                    easily create a combination of several graphs without knowing all the details on
                    the GD library or calculating pixel positions.</para>
                <para>This helper class abstracts away all the details about copying images as well
                    as offering consistent interface (almost identical with the standard Graph
                    class). A basic example will quickly reveal the elegance of using this helper
                    class. </para>
                <para>
                    <programlisting>&lt;?php
//--------------------------------------
// Graph 1
//--------------------------------------
$graph1 = new Graph(...);

//... [Code to create graph1] ...

//--------------------------------------
// Graph 2
//--------------------------------------
$graph2 = new Graph(...);

//... [Code to create graph2] ...

//--------------------------------------
// Create a combined graph
//--------------------------------------
$mgraph = new MGraph();
$xpos1=3;$ypos1=3;
$xpos2=3;$ypos2=200;
$mgraph->Add($graph1,$xpos1,$ypos1);
$mgraph->Add($graph2,$xpos2,$ypos2);
$mgraph->Stroke();
?></programlisting>
                </para>
                <para>The above example illustrates the most basic usage of the <code>MGraph</code>
                    class. </para>
                <para>Each graph is added to the combined graph with a call to
                        <code>MGraph::Add()</code> which in addition to the graph argument also
                    takes the target X and Y coordinates where the graph will be placed in the
                    combined image. The target X and Y coordinates are relative to any optional
                    specified left and top margin. </para>
                <para>In addition to adding graphs there are some basic formatting option for the
                    combined graph that are listed below. The core methods provided by the
                        <code>MGraph</code> class are </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>MGraph::MGraph($aWidth,$aHeight)</code>. </para>
                            <para>Create a new instance of the <code>MGraph</code> class. If the
                                width and height are supplied as arguments they will override the
                                automatically determined width and height. </para>
                        </listitem>
                        <listitem>
                            <para><code>MGraph::Add($aGraph,$aToX,$aToY,$aFromX,$aFromY,$aWidth,$aHeight).
                                </code></para>
                            <para>Add a new subgraph with destination position
                                    (<code>$aToX,$aToY</code>). By default the whole graph image is
                                used. It is also possible to only specify that part of the graph
                                should be used. The source rectangle is specified by <code>($aFromX,
                                    $aFromY, $aWidth, $aHeight)</code>. </para>
                        </listitem>
                        <listitem>
                            <para><code>MGraph::SetFillColor($aColor)</code>. </para>
                            <para>Background color of the combined graphs. </para>
                            <para>Example: Setting an Orange background </para>
                            <para>
                                <programlisting>$mgraph->SetFillColor('orange');</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para><code>MGraph::SetFrame($aShow,$aColor,$aWeight)</code></para>
                            <para>Adding a frame to the combined graph. </para>
                            <para>Example: To add a blue frame with a 2 pixel width </para>
                            <para>
                                <programlisting>$mgraph->SetFrame(true,'blue ',2);</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para><code>MGraph::SetMargin($aLeft,$aRight,$aTop,$aBottom)</code></para>
                            <para>Adding a margin to the image. By default the minimum necessary
                                size for the combined graph to hold all the added subgraphs is used.
                                Use this method to add some space to the edges around the combined
                                image. When the individual graphs are positioned (in the
                                    <code>Add()</code> method) the position is counted relative to
                                the left and top margin. </para>
                            <para>Example: Use 10 pixel left and right margin, 5 pixel top and
                                bottom margin </para>
                            <para>
                                <programlisting>$mgraph->SetMargin(10,10,5,5);</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para><code>MGraph::SetShadow($aShowShadow=true,$aShadowWidth=4,$aShadowColor='gray@0.3')</code></para>
                            <para>This adds a drop shadow to the MGraph in the same way as for the
                                usual graph class</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>In the same way as the ordinary Graph class the <code>MGraph</code> class also
                    have a property $footer which allows the setting of a left, center and right
                    footer (see <xref xlink:href="#sec.adding-footer"/>).</para>
                <para>In addition the <code>MGraph::Stroke()</code> accepts a filename in the same
                    way as the normal <code>Graph::Stroke()</code></para>
            </sect2>
            <sect2>
                <title>Adding background images </title>
                <para>In addition to the basic usage as shown above it is also possible to add a
                    background image in the combined graph. What is important to remember then is
                    that all the subgraphs are copied onto the combined graph so normally they will
                    be on top of the background image and hide it. </para>
                <para>There are two ways of handling a background image </para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>Do nothing and the background image will only "shine through" for
                                those areas of the combined graph that is not covered by any
                                subgraph. </para>
                        </listitem>
                        <listitem>
                            <para>Specify a "blend" factor for the subgraphs that specifies how much
                                of the background image will be mixed with the subgraph. The blend
                                factor is as usual specified as an integer in the interval 0-100.
                                (Note: This is the same functionality as the standard
                                    <code>Graph::SetBackgroundImageMix()</code> for ordinary
                                graphs.) A value of 0 means that 100% of the background is visible
                                and a value of 100 means that 0% of the background is visible. </para>
                            <para>To add a subgraphs with a blend factor the method
                                    <code>MGrahp::AddMix()</code> is used. This behaves exactly as
                                the standard <code>MGraph::Add()</code> apart from the fact that the
                                3:rd argument is the blend factor (after the two x and y
                                coordinates).</para>
                            <para>Example: Add a graph with 50% mix of the background </para>
                            <para>
                                <programlisting>$mgraph->AddMix($graph,0,0,50);</programlisting>
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>The background image itself is added with the method </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>MGraph::SetBackgroundImage($aFile,$aCenter_aX=TRUE,$aY=NULL)
                                </code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>The filename specifies the full name of the background image (including
                    extension). Please note that the extension must be a valid image extension in
                    order for the library to determine the format of the image file.</para>
                <para>The second argument can be either numeric or a boolean in which case it
                    specifies if the background image should be centered or if it should just be
                    copied from the top left position. If it is numerical it is interpretated as the
                    X-position for the optional X and Y coordinates specifying the position of the
                    top left corner of the background image. </para>
                <para><xref xlink:href="#fig.combgraphex2"/> shows a variant of <xref
                        xlink:href="#fig.combgraphex1"/> where a centered background image is mixed
                    in with two subgraphs. </para>
                <para>
                    <programlisting>#=combgraphex2|Mixing a background image with two subgraphs. In this case the mixing factor was 85 for both subgraphs. (Note: To reduce load time the image is quite hard compressed in JPEG so there are some artifacts in high-frequency areas.)#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Creating rotated combined graphs</title>
                <para>There are in principle no difference when combing graphs top/bottom or
                    left/right. ?? shows an example of creating a graph that illustrates the
                    changing weather conditions measure by Wind direction, speed and temperature in
                    one graph with a detailed vertical scale showing the time. </para>
                <para>Since this follows exactly the same principle laid out above the script should
                    be fairly self explanatory. Note that we have suppressed the x-scale on two of
                    the graphs to make better use of the available image size and also to create a
                    stronger sense of "belonging" between the individual graphs.</para>
                <para>
                    <programlisting>#=comb90dategraphex03|Combining three graphs in one image#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Some caveats when using MGraph</title>
                <para>There are some drawbacks using combined graphs</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>CSIM Image maps can not be used with combined graphs. </para>
                        </listitem>
                        <listitem>
                            <para>Creating multiple graphs in the same script will require some
                                additional memory. Make sure that the memory limit in
                                    "<filename>php.ini</filename>" is sufficient. </para>
                        </listitem>
                        <listitem>
                            <para>Adding background images can significantly increase the final size
                                of the image. Using the JPEG image format when photo like background
                                images are used gives better compressing than PNG (since JPEG is a
                                lossy format). For example setting the JPEG quality parameter to 60
                                (default is 75). </para>
                            <para>
                                <programlisting>$mgraph->SetImgFormat('jpeg',60);</programlisting>
                            </para>
                            <para>
                                <tip>
                                    <para>This setting can be used for ordinary Graphs as well.
                                    </para>
                                </tip>
                            </para>
                        </listitem>
                        <listitem>
                            <para>Compared with background images for ordinary graphs there is
                                currently no possibility for automatic re-sizing of the background
                                images. </para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect2>
        </sect1>
    </chapter>
    <chapter>
        <title>Non-Linear graph types</title>
        <para>All the plots we have discussed up to now have used some kind of x-y coordinate
            system. The library supports a number of graph types that does not use rectangular axis
            or scales. The supported graphs are shown below</para>
        <para>
            <informaltable frame="none">
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1"/>
                    <colspec colname="c2" colnum="2"/>
                    <colspec colname="c3" colnum="3"/>
                    <tbody>
                        <row>
                            <entry align="center">
                                <para>
                                    <figure>
                                        <title>Pie graphs</title>
                                        <mediaobject>
                                            <imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_pie2d.png"
                                                /></imageobject>
                                        </mediaobject>
                                    </figure>
                                </para>
                                <para>(See <xref xlink:href="#sec.pie-plots2d"/>)</para>
                            </entry>
                            <entry align="center">
                                <para>
                                    <figure>
                                        <title>Pie3D graphs</title>
                                        <mediaobject>
                                            <imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_pie3d.png"
                                                /></imageobject>
                                        </mediaobject>
                                    </figure>
                                </para>
                                <para>(See <xref xlink:href="#sec.pie-plots3d"/>)</para>
                            </entry>
                            <entry align="center">
                                <para>
                                    <figure>
                                        <title>Ring graphs</title>
                                        <mediaobject>
                                            <imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_ring.png"/></imageobject>
                                        </mediaobject>
                                    </figure>
                                </para>
                                <para>(See <xref xlink:href="#sec.ring-plots"/>)</para>
                            </entry>
                        </row>
                        <row>
                            <entry align="center">
                                <para>
                                    <figure>
                                        <title>Radar graphs</title>
                                        <mediaobject>
                                            <imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_radar.png"
                                                /></imageobject>
                                        </mediaobject>
                                    </figure>
                                </para>
                                <para>(See <xref xlink:href="#sec.radar-graphs"/>)</para>
                            </entry>
                            <entry align="center">
                                <para>
                                    <figure>
                                        <title>Polar graphs</title>
                                        <mediaobject>
                                            <imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_polar.png"
                                                /></imageobject>
                                        </mediaobject>
                                    </figure>
                                </para>
                                <para>(See <xref xlink:href="#sec.polar-graphs"/>)</para>
                            </entry>
                            <entry align="center">
                                <para>
                                    <figure>
                                        <title>Gantt charts</title>
                                        <mediaobject>
                                            <imageobject><imagedata scale="60"
                                                  fileref="images/ploticon_gantt.png"
                                                /></imageobject>
                                        </mediaobject>
                                    </figure>
                                </para>
                                <para>(See <xref xlink:href="#sec.gantt-charts"/>)</para>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </informaltable>
        </para>
        <sect1>
            <title>Pie graphs</title>
            <para>The main difference compared to the previous discussed x-y plots is that to all
                pie plots are added based on the class <code>PieGraph</code> instead of the
                    <code>Graph</code> class used for all x-y graphs.</para>
            <sect2>
                <title>Hare/Niemeyer Integer compensation for Pie Plots</title>
                <para>A problem that sometimes occur with the use of integer values for Pie charts
                    is the problem with rounding error. Even with correct rounding of the individual
                    pie slices using only integers as display values have the problem that it
                    sometimes doesn't sum up to 100% as illustrated in <xref
                        xlink:href="#fig.hare-niemeyer"/></para>
                <para>This is in many circumstances not acceptable. The library includes the
                    Hare/Niemeyer compensation that can be enabled. This will adjust the integer
                    values so that it always sum up to 100%. The result of the compensation can be
                    seen in <xref xlink:href="#fig.hare-niemeyer"/></para>
                <para>
                    <figure xml:id="fig.hare-niemeyer">
                        <title>Hare/Niemeyer pie plot integer compensation</title>
                        <informaltable frame="none">
                            <tgroup cols="2">
                                <colspec colname="c1" colnum="1"/>
                                <colspec colname="c2" colnum="2"/>
                                <tbody>
                                    <row>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/piepercent1.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>a) Problem with integer values </para>
                                        </entry>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/piepercent2.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>b) Hare/Niemeyer compensation </para>
                                        </entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </informaltable>
                    </figure>
                </para>
                <note>
                    <para>To enable this compensation the label type should be specified as </para>
                    <para>
                        <programlisting>$pieplot->SetLabelType(PIE_VALUE_ADJPERCENTAGE);</programlisting>
                    </para>
                </note>
            </sect2>
            <sect2 xml:id="sec.pie-plots2d">
                <title>2D-Pie plots</title>
                <para>In order to create Pie plots the module "<filename>jpgraph_pie.php</filename>"
                    must first be included. </para>
                <para>The principle for creating Pie graphs follows the same structure as for line
                    graphs. First an instance of <code>class PieGraph</code> is created and then one
                    or several instances of <code>class PiePlot</code> is created and added to the
                        <code>PieGraph</code> instance as the following basic example shows</para>
                <para>
                    <programlisting>#example26|A basic Pie graph#</programlisting>
                </para>
                <para>There are a few things to note here</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>By default all pie slices have the percentage shown just outside
                                the slice.</para>
                        </listitem>
                        <listitem>
                            <para>The colors are automatically assigned to the slices.</para>
                        </listitem>
                        <listitem>
                            <para>The pie have the edges marked by default</para>
                        </listitem>
                        <listitem>
                            <para>The first slice start at 0 degrees (3 o'clock)</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>It is possible to adjust most of the aspects of a pie graph. in addition to
                    the usual graph appearance adjustments discussed in <xref
                        xlink:href="#sec.overall-graph-formatting"/> the following methods can be
                    used to adjust the appearance of the individual plots.</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PiePlot::SetStartAngle($aAngle)</code></para>
                            <para>Change the angle for the first slice</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlot::ShowBorder($aFlg=true)</code></para>
                            <para>Show the border around and inside the pie</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlot::SetColor($aColor)</code></para>
                            <para>Specify the color of the border of the pie </para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlot::SetSliceColors($aColor)</code></para>
                            <para>Specify the color of the slices</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlot::SetSize($aSize)</code></para>
                            <para>Set the size of the pie plot. This can be specified as either a
                                fraction of the minimum of the graph width and height or as a
                                absolute size in pixels.</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlot::SetCenter($aX, $aY)</code></para>
                            <para>Position the pie on the graph</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlot::value</code></para>
                            <para/>
                        </listitem>
                        <listitem>
                            <para><code>PiePlot::SetLabels($aLabels,
                                $aLblPosAdj="auto")</code></para>
                            <para>Specify the labels for each pie slice</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlot::SetLabelType($aType)</code></para>
                            <para>By default the label is displayed as percentage. Using this method
                                it is possible to change the automatic label to show the absolute
                                value instead.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>In order to show a basic addition we add a legend to the pie graph. We do this
                    by using the <code>SetLegends()</code> method. By adding the legends to the
                    previous example we get the result shown in <xref xlink:href="#fig.example26.1"
                    /></para>
                <para>
                    <programlisting>#=example26.1|Adding a legend to a pie plot#</programlisting>
                </para>
                <para>
                    <note>
                        <para>In the figure above we also moved the center of the pie slightly to
                            the left to make more room for the legend box.</para>
                    </note>
                </para>
                <para>The text for the legends can also contain <code>printf()</code> style format
                    strings to format a number. The number passed on into this string is either the
                    absolute value of the slice or the percentage value. The same formatting can
                    also be used to format the legend labels.</para>
                <sect3>
                    <title>Adding multiple pie plots to the same pie graph</title>
                    <para>This is done in complete analogy with the say multiple lines were added to
                        a line graph. The following code snippet shows the principle</para>
                    <para>
                        <programlisting>&lt;?php
$piegraph = new PieGraph($width,$height);

$p1 = new PiePlot($data1);
$p1->SetSize(0.2);
$p1->SetCenter(0.3,0.6);

$p2 = new PiePlot($data2);
$p2->SetSize(0.2);
$p2->SetCenter(0.7,0.6);

$piegraph->Add($p1);
$piegraph->Add($p2);
?></programlisting>
                    </para>
                    <para>The positioning and sizing of the plots must be done manually. In the
                        following example we show an example where four pie plots are added to a
                        graph</para>
                    <para>
                        <programlisting>#pieex3|Adding several pie plots to the same pie graph#</programlisting>
                    </para>
                </sect3>
                <sect3>
                    <title>Adding guide lines to Pie Plots</title>
                    <para>For very busy Pie plots it can become too little space for the labels to
                        be printed just beside the pie slice. For this purpose it is possible to use
                        guide lines for the labels. The library will then draw a line from the
                        center edge of the slices to the label which will be positioned further out
                        from the Pie Plot.</para>
                    <para>There is one method that is primarily used to handle this</para>
                    <para>
                        <itemizedlist>
                            <listitem>
                                <para><code>PiePlot::SetGuideLines($aFlg=true, $aCurved=true,
                                        $aAlways=false)</code></para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>the simplest usage of this would be to add the following line to a
                        script</para>
                    <para>
                        <programlisting>$pieplot->SetGuideLines(); </programlisting>
                    </para>
                    <para><xref xlink:href="#fig.pielabelsex1"/> shows an example of this.</para>
                    <para>This basic use of guide lines is very similar as what is produced by other
                        programs, e.g. Excel. In addition to the above variant it is also possible
                        to instruct the library to line up the labels vertically in a way that we
                        think is easier to read. </para>
                    <para>This is achieved by specifying the second parameter to the
                            <code>SetGuideLines()</code> to '<code>false</code>' as </para>
                    <para>
                        <programlisting>$pieplot->SetGuideLines( true , false ); </programlisting>
                    </para>
                    <para>The first parameter is to enable/disable the guide-lines. With the same
                        example as above this would then produce the image shown in <xref
                            xlink:href="#fig.pielabelsex2"/></para>
                    <para>
                        <informaltable frame="none">
                            <tgroup cols="2">
                                <colspec colname="c1" colnum="1"/>
                                <colspec colname="c2" colnum="2"/>
                                <tbody>
                                    <row>
                                        <entry>
                                            <programlisting>#=pielabelsex1|Adding guide lines to a pie labels#</programlisting>
                                        </entry>
                                        <entry>
                                            <programlisting>#=pielabelsex2|Lining up guide lines vertically#</programlisting>
                                        </entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </informaltable>
                    </para>
                    <para>It is also possible to configure the vertical distance between the labels.
                        By default the distance between the labels is roughly 40% of the labels font
                        height. By using the method <code>PiePlot::SetGuideLinesAdjust()</code> it
                        is possible to specify a fractional value which is interpretated as the
                        distance between the bottom of one label to the bottom of the next. This
                        means that specifying a value of '1.0' the labels will have no space between
                        them and the bottom of one label will touch the top of another label. By
                        default this value is 1.4.</para>
                    <para>By increasing or decreasing this value it is possible to make the labels
                        become positioned more or less compact. In ?? this distance is reduced to
                        '1.1' and as can be seen this yields much more compact labeling.</para>
                    <para>
                        <programlisting>#=pielabelsex4|Adjusting the distance between the labels for guide lines#</programlisting>
                    </para>
                    <para>
                        <note>
                            <para>Guide lines is only available for 2D Pie plots.</para>
                        </note>
                    </para>
                </sect3>
            </sect2>
            <sect2 xml:id="sec.pie-plots3d">
                <title>3D-Pie plots</title>
                <para>In order to create 3D Pie plots both the modules
                        "<filename>jpgraph_pie.php</filename>" and
                        "<filename>jpgraph_pie3d.php</filename>" must be included. </para>
                <para>Creating 3D pie plots is as simple as creating normal 2D pie plots. Instead of
                    creating the plots as an instance of <code>class PiePlot</code> the plots are
                    created as an instance of <code>class PiePlot3D</code>
                </para>
                <para>If we take the plot in <xref xlink:href="#fig.example26"/> and replace the
                    creation of an instance of <code>class PiePlot</code> with creating an instance
                    of <code>class PiePlot3D</code> , i.e. replace</para>
                <para>
                    <programlisting>$p1 = new PiePlot($data);</programlisting>
                </para>
                <para>with</para>
                <para>
                    <programlisting>$p1 = new PiePlot3D($data);</programlisting>
                </para>
                <para>The result of this is shown in <xref xlink:href="#fig.example27"/></para>
                <para>
                    <programlisting>#=example27|A basic 3D pie plot#</programlisting>
                </para>
                <para>3D Pie plots have the same possibilities as the normal pie plots with the
                    added twist of a 3:rd dimension. It is possible to adjust the perspective angle
                    with the method <code>SetAngle()</code> So for example to make the pie more
                    "flat" the angle is made smaller angle. Setting the perspective angle to 20
                    degrees in the previous example will give the following result.</para>
                <para>
                    <programlisting>#=example27.1|Adjusting the perspective angle#</programlisting>
                </para>
                <para>To give a feel for the effect of adjusting the angle <xref
                        xlink:href="#fig.adjusting-pie3d-angle"/> below shows a number of different
                    angles,</para>
                <para>
                    <figure xml:id="fig.adjusting-pie3d-angle">
                        <title>Affect of adjusting the perspective angle for a 3D pie plot</title>
                        <informaltable frame="none">
                            <tgroup cols="4">
                                <colspec colname="c1" colnum="1"/>
                                <colspec colname="c2" colnum="2"/>
                                <colspec colname="c3" colnum="3"/>
                                <colspec colname="c4" colnum="4"/>
                                <tbody>
                                    <row>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/img_mmpie3d_10.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>angle=10</para>
                                        </entry>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/img_mmpie3d_20.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>angle=20</para>
                                        </entry>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/img_mmpie3d_30.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>angle=30</para>
                                        </entry>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/img_mmpie3d_40.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>angle=40</para>
                                        </entry>
                                    </row>
                                    <row>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/img_mmpie3d_50.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>angle=50</para>
                                        </entry>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/img_mmpie3d_60.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>angle=60</para>
                                        </entry>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/img_mmpie3d_70.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>angle=70</para>
                                        </entry>
                                        <entry align="center">
                                            <para><inlinemediaobject><imageobject><imagedata
                                                  scale="60" fileref="images/img_mmpie3d_80.png"
                                                  /></imageobject></inlinemediaobject></para>
                                            <para>angle=10</para>
                                        </entry>
                                    </row>
                                </tbody>
                            </tgroup>
                        </informaltable>
                    </figure>
                </para>
            </sect2>
            <sect2 xml:id="sec.ring-plots">
                <title>Ring plots</title>
                <para>There are two versions of the 2D pie plots. The normal pie plot is created as
                    an instance of <code>class PiePlot</code>. This variant is created as an
                    instance of <code>class PiePlotC</code>.</para>
                <para>This variant is an extension of the standard PiePlot in the sense that it also
                    have a filled circle in the center. An example of this is shown in ??</para>
                <para>
                    <programlisting>#=piecex1|A ring plot#</programlisting>
                </para>
                <para>Since the <code>PiePlotC</code> is an extension to the basic pie plot all the
                    normal formatting for pie plots can also be done for a "ring" plot.</para>
                <para>The additional formatting only concerns the filled middle circle. There are
                    options of adjusting size, fill color and all font properties. The following
                    methods are used for this</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PiePlotC::SetMidColor() </code></para>
                            <para> Set fill color of mid circle</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlotC::SetMidSize()</code></para>
                            <para>Set size (fraction of radius)</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlotC::SetMidTitle()</code></para>
                            <para>Set title string (may be multi-lined)</para>
                        </listitem>
                        <listitem>
                            <para><code>PiePlotC::SetMid()</code></para>
                            <para> Set all parameters in a single method call</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>In addition to the normal CSIM for PiePlot:s the center area is also a CSIM
                    hotspot. You specify the target CSIM with a call to </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PiePlotC::SetMidCSIM()</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>A more complex formatting of a ring plot is shown in <xref
                        xlink:href="#fig.piecex2"/>. In this example we have:</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para>hidden the frame around the pie graph</para>
                        </listitem>
                        <listitem>
                            <para>exploded all the slices</para>
                        </listitem>
                        <listitem>
                            <para>added drop shadow to the individual slices (and the center filled
                                circle)</para>
                        </listitem>
                        <listitem>
                            <para>specified individual multi line labels.</para>
                        </listitem>
                        <listitem>
                            <para>changed the font for the title to a TTF font.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>
                    <programlisting>#=piecex2|A ring graph with several formatting options adjusted#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Exploding pie slices</title>
                <para>One way to attract attention to some specific piece of information in a pie
                    chart is to "explode" one or more slices. Both 2D and 3D pies support exploding
                    one or several slices.</para>
                <para>Exploding slices is accomplished by the methods </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PiePlot::Explode($aExplodeArr)</code></para>
                            <para>This method takes an array of one or more slices index to
                                explode</para>
                            <para><code>PiePlot::ExplodeAll($aRadius)</code></para>
                            <para>This explodes all slices in the pie</para>
                            <para><code>PiePlot::ExplodeSlice($aSlice, $aRadius)</code></para>
                            <para>This is used to explode one specific slice</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>To explode one slice the default "explode" radius the following line has to be
                    added</para>
                <para>
                    <programlisting>$pieplot->ExplodeSlice( 1 );</programlisting>
                </para>
                <para>The above line would explode the second slice (slices are numbered from 0 and
                    upwards) the default amount. Doing this to the previous examples would result in
                    the following two figures</para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=example27.2|Exploding the second slice#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=example27.3|Exploding the second slice#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sect2>
            <sect2>
                <title>Specifying and adjusting labels on pie plots</title>
                <para>By default the values shown just outside the pie for each slice are the
                    percentage value for each slice. If instead the absolute value should be
                    displayed the <code>SetLabelType()</code> method must be called. To show
                    absolute values the following line must be added</para>
                <para>
                    <programlisting>$pieplot->SetLabelType(PIE_VALUE_ABS); </programlisting>
                </para>
                <para>Furthermore is is possible to adjust the display value by either using a
                        <code>printf()</code> style format string (using <code>SetFormat()</code> )
                    or by providing a formatting function callback (using
                        <code>PiePlot::SetFormatCallback()</code> ) for doing more advanced
                    formatting.</para>
                <para>It is also possible to adjust the position of the labels by means of the
                        <code>PiePlot::SetLabelPos()</code> method. The argument to this method is
                    either the fraction of the radius or the string '<code>auto</code>'. In the
                    latter case the library automatically determines the best position. The
                    following example illustrates the effect of specifying the position to 0.5, i.e.
                    in the middle of the radius.</para>
                <para>
                    <programlisting>#=pieex8|Adjusting the position of the pie labels#</programlisting>
                </para>
                <para>If this formatting is not enough it is also possible to "manually" specify the
                    labels for each slice individually. </para>
                <para>This is done by using the <code>PiePlot::SetLabels()</code> method. This will
                    allow specifying individual text strings for each label. In each specification
                    it is possible to add a <code>printf()</code> formatting specification for a
                    number. The number passed on will be either the absolute value for the slice or
                    the percentage value depending on what was specified in the call to
                        <code>SetLabelType()</code>. </para>
                <para>The <code>SetLabels()</code> method can also take a second parameter, the
                    label position parameter. This is a shortcut to the
                        <code>PiePlot::SetLabelPos()</code> as described above. By default the
                    position will be set to '<code>auto</code>' if not explicitly specified.</para>
                <note>
                    <para>The alignment of the labels will be different depending on whether they
                        are inside or outside the pie. </para>
                    <para>When the label is positioned inside the plot the center of the strings
                        will be aligned with the center of the slice at the specified fraction of
                        the radius. When positioned is outside the pie plot the alignment will
                        depend on the angle to avoid that the labels inadvertently writes over the
                        pie.</para>
                </note>
                <para>When labels are specified with the <code>PiePlot::SetLabels()</code> method it
                    is possible to also specify a format placeholder (in the normal style of
                        <code>printf()</code> this placeholder will be replaced by the value of the
                    slice. For example a label specified as <code>"The apple slice\n%.1f%%"</code>
                    would have the percentage value on the second row. The value will either be the
                    absolute or the percentage depending on the setting of the
                        <code>SetLabelType()</code>.. The Pie chart in <xref
                        xlink:href="#fig.pielabelsex5"/> below shows an example where the slices
                    have a label just outside the perimeter of the pie. </para>
                <para>
                    <programlisting>#=pielabelsex5|Pie chart with manually specified labels for each slice#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Adding drop shadows to the slices</title>
                <para>An additional visual enhancements can be made by adding a drop shadow to the
                    individual slices. This is accomplished by means of the </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PiePlot::SetShadow() </code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>method. Adding a drop shadow is often more affective if the pie has one or
                    more slices exploded as shown in ??</para>
                <para>
                    <programlisting>#=pieex9|Adding a drop shadow to exploded pie#</programlisting>
                </para>
            </sect2>
            <sect2 xml:id="sec.pie-image-background">
                <title>Adding background images to Pie graphs</title>
                <para>In the same way as every other graphs in the library it is possible to add a
                    background image to a Pie plot (see <xref
                        xlink:href="#sec2.img-country-background"/>). An example of this where we
                    have used multiple plots on a worldmap background is shown in <xref
                        xlink:href="#fig.piebkgex1"/></para>
                <para>
                    <programlisting>#piebkgex1|Pie plots with a background image#</programlisting>
                </para>
            </sect2>
            <sect2 xml:id="sec.pie-color-themes">
                <title>Specifying slice colors and using themes</title>
                <para>In addition to manually specifying the colors of each individual pie slice it
                    is possible to specify a color "theme" to be used. A color theme is nothing more
                    than a group of predefined colors that will be used for the slices. Each theme
                    is referred to by it's name (as a string) as argument for the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PiePlot::SetTheme($aTheme)</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>By default the library offers four different color themes listed below with a
                    small example graph using that particular theme. </para>
                <para>
                    <orderedlist>
                        <listitem>
                            <para>"earth" colors</para>
                            <para>
                                <programlisting>#=example28.1#</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>"pastel" colors</para>
                            <para>
                                <programlisting>#=example28.2#</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>"sand" colors</para>
                            <para>
                                <programlisting>#=example28#</programlisting>
                            </para>
                        </listitem>
                        <listitem>
                            <para>"water" colors</para>
                            <para>
                                <programlisting>#=example28.3#</programlisting>
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
                <para>Color chart for each available theme is shown below.</para>
                <figure>
                    <title>Earth theme</title>
                    <mediaobject>
                        <imageobject><imagedata fileref="images/pie_theme_earth.png"/></imageobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Pastel theme</title>
                    <mediaobject>
                        <imageobject><imagedata fileref="images/pie_theme_pastel.png"
                            /></imageobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Sand theme</title>
                    <mediaobject>
                        <imageobject><imagedata fileref="images/pie_theme_sand.png"/></imageobject>
                    </mediaobject>
                </figure>
                <figure>
                    <title>Water theme</title>
                    <mediaobject>
                        <imageobject><imagedata fileref="images/pie_theme_water.png"/></imageobject>
                    </mediaobject>
                </figure>
            </sect2>
        </sect1>
        <sect1 xml:id="sec.radar-graphs">
            <title>Radar graphs</title>
            <para>In order to create Radar graphs the module
                "<filename>jpgraph_radar.php</filename>" must first be included. </para>
            <para>Radar plots are most often used to display how a number of results compare to some
                set targets. They make good use of the human ability to spot symmetry (or rather
                un-symmetry). Radar plots are not suitable if high accuracy readings from the graph
                are needed since, by it's nature, it can be difficult to read out very detailed
                values. </para>
            <para><xref xlink:href="#fig.radarex7"/> shows a basic radar graph with two radar plots
                added.</para>
            <para>
                <programlisting>#=radarex7|A typical radar graph with two radar plots added#</programlisting>
            </para>
            <para>Radar graphs are created as an instance of <code>class RadarGraph</code> which
                inherits all common formatting options from the standard <code>class Graph</code>
                such as titles, background colors, background titles, etc. </para>
            <para>
                <note>
                    <para>Tabbed titles cannot not be used for radar graphs since there is no
                        applicable concept of a plot area</para>
                </note>
            </para>
            <para>The following facts applies to a radar graph</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>There is one axis for each data point</para>
                    </listitem>
                    <listitem>
                        <para>Each axis may have an arbitrary title which is automatically
                            positioned</para>
                    </listitem>
                    <listitem>
                        <para>A radar plot may be filled or open</para>
                    </listitem>
                    <listitem>
                        <para>The first axis is always oriented vertical and is the only axis with
                            labels</para>
                    </listitem>
                    <listitem>
                        <para>Several radar plots can be combined in one radar graph</para>
                    </listitem>
                    <listitem>
                        <para>Axis can have either linear or logarithmic scale on the axis</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>In addition all the normal formatting of labels, background colors, grid lines,
                plot colors, fill colors etc. can be adjusted. The rest of this sections will show
                some of the typical formatting options available.</para>
            <sect2>
                <title>Adding radar plots to a radar graph</title>
                <para>The principle is exactly the same as for line plots but instead of an x-y
                    coordinate each data point represents a value on one of the axis. The number of
                    axis will automatically be the same as the number of data points. Even through
                    the library itself does not impose any restrictions on the number of axis there
                    is a practical limit so it is probably best to keep the number of data points
                    limited to around 10-12.</para>
                <para>Typical data set for a radar plot is then given as</para>
                <para>
                    <programlisting>$data = array( axis&lt;1>_value, axis&lt;2>_value, ..., axis&lt;n>_value );</programlisting>
                </para>
                <para>The plot points are assigned to the axis in a counter-clockwise direction
                    starting at 12 a'clock. If clock-wise order is needed the input data must be
                    reversed.</para>
                <para>Creation of a radar graph follows the now familiar steps of first creating an
                    instance of <code>class RadarGraph</code> and then adding one or several
                    instances of <code>class RadarPlot </code>as the following code snippet
                    shows</para>
                <para>
                    <programlisting>&lt;?php
// Some data
$data1 = array( ... ) ;
$data2 = array( ... ) ;

$width  = ... ;
$height = ... ;

// Setup a basic radar graph
$graph = new RadarGraph($width,$height);
$graph->SetScale('lin');

// Add a title to the graph
$graph->title->Set('Quality result');

// .. add any other common graph formatting

// Create the first radar plot with formatting
$plot1 = new RadarPlot($data1);
$plot1->SetLegend('Goal');
$plot1->SetColor(ÕÑred', 'lightred');

// Create the second radar plot
$plot2 = new RadarPlot($data2);
$plot2->SetLegend('Actual');
$plot2->SetColor('blue', 'lightred');

// Add the plots to the graph
$graph->Add($plot2);
$graph->Add($plot1);

// and display the graph
$graph->stroke()
?></programlisting>
                </para>
                <para>As an illustration two very basic radar graphs with one radar plot each are
                    displayed below. The left figure uses only default values and the right figure
                    uses the ame data but adjusts a few properties to make the graph a bit more
                    interesting.</para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=radarex1|A basic radargraph with no formatting#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=radarex2|A basic radargraph with minimal formatting#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para>Each radar plot can also have a legend. As usual the text for the legend is
                    created by using the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarPlot::SetLegend($aText)</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>The legend box is accessed through the "$legend" property of the graph and
                    this can be used to adjust the size, position and layout of the legend box (as
                    described in <xref xlink:href="#sec1.adjusting-legend-position"/>).</para>
            </sect2>
            <sect2>
                <title>Adding plot-marks to radar plots</title>
                <para>In exactly the same way as for line graphs it is possible to add plot marks in
                    radar plots. The mark property is accessed through the instance variable</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarPlot::mark </code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>(All available plot marks are listed in <xref xlink:href="#app.plotmark-list"
                    />)</para>
                <para>For example to add a red ball marker the following line must be added</para>
                <para>
                    <programlisting>$radarplot->mark->SetType(MARK_IMG_SBALL,'red');</programlisting>
                </para>
                <para>In <xref xlink:href="#fig.radarmarkex1"/> we show a radar graph with added
                    plot-marks. In addition we have also chosen to hide the tick marks on the axis
                    and adjust some of the default colors.</para>
                <para>
                    <programlisting>#=radarmarkex1|Adding plot marks to a radar graph#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Client Side Image maps</title>
                <para>(See <xref xlink:href="#chap.using-csim"/> for a full description on the usage
                    of CSIM together with the library)</para>
                <para>If markers are shown for the polar plot (by setting the mark property of the
                    plot) each marker can be a hot spot in a client side image map. The target URL
                    are as usual specified with the<code> SetCSIMTargets()</code> as the following
                    short code snippet shows</para>
                <para>
                    <programlisting>&lt;?php
// Start by specifying the proper URL targets
$targets  = array( "#1" , "#2" , ....... );
$radarplot = new RadarPlot( $data );
$radarplot->mark->SetType( MARK_SQUARE );
$radarplot->SetCSIMTargets( $targets );
$graph->Add( $radarplot );
$graph->StrokeCSIM(); 
?></programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Adjusting the overall properties of the radar graph</title>
                <para>The scale of the axis can be either a linear or a logarithmic scale and is
                    specified with the method</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarGraph::SetScale($aScale, $aYMin=1,
                                $aYMax=1)</code></para>
                            <para>The scale is specified as a string and can be either
                                    "<code>lin</code>" or "<code>log</code>"</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>The size and position of the radar graph are adjusted by the two
                    methods</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarGraph::SetSize($aSize)</code></para>
                            <para>The size is specified as a fraction of min($weight,$height) and
                                indicates the length of the axis.</para>
                        </listitem>
                        <listitem>
                            <para><code>RadarGraph::SetCenter($aXPos, $aYPos=0.5)</code></para>
                            <para>The center of the graph can be specified as either a fraction of
                                the width/height or as an absolute position.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>The background color can be adjusted by</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarGraph::SetColor($aColor)</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect2>
            <sect2>
                <title>Adjusting the axis formatting</title>
                <para>All axis have the same formatting and the axis is access through the "$axis"
                    property of the RadarGraph class. For example make the axis 2 pixels wide the
                    following lines would be needed</para>
                <para>
                    <programlisting>$radargraph = new RadarGraph($width,$height);
$radargraph->axis->SetWeight(2);</programlisting>
                </para>
                <para>The axis supports all the same formatting options as for standard x-y graphs.
                    Some of the more commonly used methods for the axis formatting are</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>Axis::SetColor($aColor,$aLabelColor=false)</code></para>
                            <para>Set the color of the axis and (optional) the labels </para>
                        </listitem>
                        <listitem>
                            <para><code>Axis::SetWeight($aWeight)</code></para>
                            <para>Specifies width in pixels of the axis</para>
                        </listitem>
                        <listitem>
                            <para><code>Axis::SetLabelFormatString($aFormStr,$aIsDateFormat=false)</code></para>
                            <para>Specify the format string to be used for the labels </para>
                        </listitem>
                        <listitem>
                            <para><code>Axis::SetLabelFormatCallback($aFuncName)</code></para>
                            <para>Set the callback function to be used for the label
                                formatting</para>
                        </listitem>
                        <listitem>
                            <para><code>Axis::SetFont($aFamily,$aStyle,$aSize)</code></para>
                            <para>Sets the font property for the labels of the axis. Note that this
                                will <emphasis role="bold">not</emphasis> effect the font property
                                of the title of the axis.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>In order to specify the titles for each axis the method </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarGraph::SetTitles($aTitleArray)</code></para>
                            <para>The argument is an array with as many entries as there are axis
                                and where each entry specifies a text string which is the title of
                                the axis.</para>
                            <example>
                                <title>Having the name of the months as title of the axis</title>
                                <para>The easiest way to have the month name as titles is to use the
                                    library global variable "<code>$gDateLocale</code>" as
                                    follows</para>
                                <para>
                                    <programlisting>$titles = $gDateLocale->GetShortMonth();
$radargraph->SetTitles( $titles ); </programlisting>
                                </para>
                            </example>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>In order to adjust the property of the title for the axis the
                        "<code>$title</code>" property of the axis is used. For example, to set the
                    font and color for the titles of the axis the following two lines are
                    needed</para>
                <para>
                    <programlisting>&lt;?php
$radargraph->axis->title->SetFont(FF_ARIAL,FS_BOLD,12);
$radargraph->axis->title->SetColor('darkred');
?></programlisting>
                </para>
                <para>The tick marks can also be adjusted with the following methods</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarGraph::HideTickMarks($aFlag=true)</code></para>
                            <para>Hide all tick marks</para>
                        </listitem>
                        <listitem>
                            <para><code>RadarGraph::ShowMinorTickmarks($aFlag=true)</code></para>
                            <para>Enable/Disable tick marks</para>
                        </listitem>
                        <listitem>
                            <para><code>RadarGraph::SetTickDensity($aDensity=TICKD_NORMAL)</code></para>
                            <para>Adjust the tick density</para>
                        </listitem>
                    </itemizedlist>
                </para>
            </sect2>
            <sect2>
                <title>Adjusting grid lines for the radar graph</title>
                <para>Each major tick mark can also be connected together to create a grid in the
                    graph. The grid is accessed through the '<code>$grid</code>' property of the
                    graph. To enable the grid and set the line style to "dotted" the following two
                    lines must be added</para>
                <para>
                    <programlisting>$radargraph->grid->Show ();
$radargraph->grid->SetLineStyle( 'dashed' );</programlisting>
                </para>
                <para>An example of dashed grid lines are shown in <xref xlink:href="#fig.radarex4"
                    />. By default the grid lines have a gray color and are drawn behind the radar
                    plot and hence part of the grid lines are obscured.</para>
                <para>The property of the grid lines are adjusted by accessing the
                        "<code>$grid</code>" line. The available methods to format grid lines
                    are:</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarGraph::grid::Show($aShowMajor=true)</code></para>
                            <para>Enable grid lines</para>
                        </listitem>
                        <listitem>
                            <para><code>RadarGraph::grid::SetColor($aMajColor)</code></para>
                            <para>Set the color of the grid lines</para>
                        </listitem>
                        <listitem>
                            <para><code>RadarGraph::grid::SetWeight($aWeight)</code></para>
                            <para>Set the weight of the grid line</para>
                        </listitem>
                        <listitem>
                            <para><code>RadarGraph::grid::SetLineStyle($aType)</code></para>
                            <para>Set the line style, can be one of
                                    "<code>dotted</code>","<code>dashed</code>","l<code>ong-dash</code>","<code>solid</code>"</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>To make the grid lines in <xref xlink:href="#fig.radarex4"/> more visible lets
                    change the color by using the <code>SetColor()</code> method on the grid. In
                    addition we can also adjust the background color. The result of this is shown in
                        <xref xlink:href="#fig.radarex6"/></para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=radarex4|Enabling a dashed grid line#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=radarex6|Enabling a dashed grid line with red#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sect2>
            <sect2>
                <title>Using a logarithmic scale</title>
                <para>In order to change the (default) linear scale o the axis to use logarithmic
                    scale the following line must be added: </para>
                <para>
                    <programlisting>$graph->SetScale('log');</programlisting>
                </para>
                <para>
                    <xref xlink:href="#fig.radarlogex1"/> shows an example of a logarithmic radar
                    graph </para>
                <para>
                    <programlisting>#=radarlogex1|Using a logarithmic scale#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Enabling anti-aliasing for radar graphs</title>
                <para>Radar graph are an excellent example where enabling anti-alias can make a
                    large visual difference. In order to enable anti-aliasing the method </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>RadarGraph::img::SetAntiAliasing($aFlg=true)</code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>must be called, for example as in</para>
                <para>
                    <programlisting>$radargraph->img->SetAntiAliasing();</programlisting>
                </para>
                <para>To give an example of this <xref xlink:href="#fig.radarlogex1-aa"/> shows an
                    anti-aliased version of <xref xlink:href="#fig.radarlogex1"/> . (Another
                    comparative example of enabling anti-aliasing is also given in <xref
                        xlink:href="#fig.radarex8"/> and <xref xlink:href="#fig.radarex8.1"
                    />.)</para>
                <para>
                    <programlisting>#=radarlogex1-aa|Enabling anti-alias for the logarithmic radar example#</programlisting>
                </para>
                <para>
                    <caution>
                        <para>Remember the limitation when using anti-aliasing that lines will be
                            given line weight=1 regardless of the specified weight.</para>
                    </caution>
                </para>
            </sect2>
            <sect2>
                <title>A final example</title>
                <para>As a final example we shown a radar graphs were we have adjusted many of the
                    available properties, such as specifying a manual scale, to achieve the result
                    shown in <xref xlink:href="#fig.fixscale_radarex1"/></para>
                <para>
                    <programlisting>#fixscale_radarex1|A more complex example of a radar graph with a manual scale#</programlisting>
                </para>
            </sect2>
        </sect1>
        <sect1 xml:id="sec.polar-graphs">
            <title>Polar graphs</title>
            <para>In order to create Radar graphs the module
                "<filename>jpgraph_polar.php</filename>" must first be included.</para>
            <para>Each data point in a polar plot is represented by a tuple consisting of a radius
                and an angle. The polar plot itself can be either outlined or filled. In addition
                each point may have a standard marker (the same as for line and scatter plots). </para>
            <para>The scale for the radius can be either linear or logarithmic.</para>
            <para>A polar graph is created by creating an instance of <code>class PolarGraph</code>.
                The polar graph type inherits all the capabilities of ordinary x,y graphs, i.e they
                can have background images, background gradients, formatted titles, using tabbed
                titles etc.</para>
            <para>There are two types of polar graphs, full 360 degree view or just 180 degree view.
                The figures below show the difference between these two graph types.</para>
            <para>
                <informaltable frame="none">
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1"/>
                        <colspec colname="c2" colnum="2"/>
                        <tbody>
                            <row>
                                <entry>
                                    <programlisting>#=polarex0|A full 360 degree polar graph#</programlisting>
                                </entry>
                                <entry>
                                    <programlisting>#=polarex0-180|A 180 degree (half) polar graph#</programlisting>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>The choice is controlled with the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>PolarGraph::SetType($aType)</code></para>
                        <para><code>$aType</code> is specified with the symbolic defines</para>
                        <para>
                            <itemizedlist>
                                <listitem>
                                    <para><code>POLAR_360</code>, The default</para>
                                </listitem>
                                <listitem>
                                    <para><code>POLAR_180</code></para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>As an example of using some more of the available formatting that is discussed in
                later sections <xref xlink:href="#fig.polarex7-2"/> shown a full 360 degree plot
                with both background gradient as well as using alpha blending for the fill of the
                polar plot.</para>
            <para>
                <programlisting>#=polarex7-2|A 360 polar plot with background gradient and alpha blending#</programlisting>
            </para>
            <para/>
            <sect2>
                <title>Rotating the polar graph</title>
                <para>
                    <caution>
                        <para>There is a bug in versions before v3.0.4 so that a rotated polar graph
                            must always have equal margins on all side to work as expected.</para>
                    </caution>
                </para>
                <para>By default the start angle (angle=0) is located at the 3'a clock position. By
                    calling the method <code>Graph::Set90AndMargin()</code> it is possible to rotate
                    the graph so that the 0-angle position is at the 6'a clock position (straight
                    down). This is mostly used for full 360 degree graphs.</para>
            </sect2>
            <sect2>
                <title>Changing the angle direction</title>
                <para>
                    <note>
                        <para>This is only available in v3.0.4 of the library and above.</para>
                    </note>
                </para>
                <para>By default the angle is counted counter-clockwise as is custom in most
                    application of polar plots. However, it is also possible to have the angles
                    counted clockwise. This is done by calling the method
                        <code>Graph::SetClockwise()</code>. </para>
                <para>In the following two examples we show a full 360 degree polar plots with
                    clockwise ordering in both a standard configuration and also as a 90 degrees
                    rotated graph.</para>
                <para>
                    <informaltable frame="void">
                        <tbody>
                            <tr>
                                <td>
                                    <programlisting>#=polarclockex1|Clockwise polar graph#</programlisting>
                                </td>
                                <td>
                                    <programlisting>#=polarclockex2|Rotated clockwise polar graph#</programlisting>
                                </td>
                            </tr>
                        </tbody>
                    </informaltable>
                </para>
            </sect2>
            <sect2>
                <title>Adding polar plots to a polar graph</title>
                <para>The principle is exactly the same as for line plots but instead of an x-y
                    coordinate each point is represented by a angle and a radius to specify its
                    position. The data is given in the format</para>
                <para>
                    <programlisting>$data = array(angle1, radius1, angle2, radius2, ...)</programlisting>
                </para>
                <para>Creation of a single polar plot follows the now familiar structure as shown in
                    the following code snippet</para>
                <para>
                    <programlisting>&lt;?php
...
// Setup the graph
$graph = new PolarGraph($width,$height);

// Set a logarithmic scale with 100 as the maximum value, i.e. 10^2
$graph->SetScale('log',100);

// Use a full 360 degree polar graph
$graph->SetType(POLAR_360);

// Create a plot with marks
$polarplot = new PolarPlot($data);
$polarplot->mark->SetType(MARK_SQUARE);

// Add it to the graph
$graph->Add($polarplot);
...
?></programlisting>
                </para>
                <para>Adding multiple polar plots follows the same pattern. Each polar plot is
                    created as an instance of <code>class PolarPlot</code> and then added to the
                    graph.</para>
            </sect2>
            <sect2>
                <title>Adding plot-marks to polar plots</title>
                <para>In exactly the same way as for line graphs it is possible to add plot marks in
                    radar plots. The mark property is accessed through the instance variable</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PolarPlot::mark </code></para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>(All available plot marks are listed in <xref xlink:href="#app.plotmark-list"
                    />)</para>
                <para>For example to add a square marker (with the default color) the following line
                    must be added</para>
                <para>
                    <programlisting>$polarplot->mark->SetType(MARK_SQUARE);</programlisting>
                </para>
                <para>In <xref xlink:href="#fig.polarex7-1"/> we show a polar graph with added
                    plot-marks. In addition we have added a gradient background.</para>
                <para>
                    <programlisting>#=polarex7-1|Adding plot marks to a polar graph#</programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Client Side Image maps</title>
                <para>(See <xref xlink:href="#chap.using-csim"/> for a full description on the usage
                    of CSIM together with the library)</para>
                <para>If markers are shown for the polar plot (by setting the mark property of the
                    plot) each marker can be a hot spot in a client side image map. The target URL
                    are as usual specified with the<code> SetCSIMTargets()</code> as the following
                    short code snippet shows</para>
                <para>
                    <programlisting>&lt;?php
// Start by specifying the proper URL targets
$targets  = array( "#1" , "#2" , ....... );
$polarplot = new PolarPlot( $data );
$polarplot->mark->SetType( MARK_SQUARE );
$polarplot->SetCSIMTargets( targets );
$graph->Add( $polarplot );
$graph->StrokeCSIM(); 
?></programlisting>
                </para>
            </sect2>
            <sect2>
                <title>Adjusting the radius scale</title>
                <para>The radius axis can be shown in either a linear or logarithmic scale. This is
                    controlled by a call to </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PolarGraph::SetScale($aScale,$aRadiusMax=0)</code></para>
                            <para>Supported scale types for <code>$aScale</code> are the strings
                                    "<code>lin</code>" or "<code>log</code>". The second argument is
                                an optional manual setting of the maximum scale value for the
                                radius.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>The two examples below show the same plot in either linear or logarithmic
                    scale for the radius</para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=polarex3-lin|Linear scale for radius#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=polarex3|Logarithmic scale for radius#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
                <para>Please note that the maximum values of the scales are different.</para>
                <para>By default the scale will be auto scaled depending on the data. It is also
                    possible to specify a manual scale by supplying an extra argument to the
                        <code>SetScale()</code> method. </para>
                <para>The only difference from the manual scaling with the standard x-y-graphs is
                    that for polar graph only the maximum value is manually specified. The minimum
                    will always be 0 for the linear scale and a scaled value of 10 (i.e 1, 0.1,
                    0.001 and so on) for the logarithmic scale.</para>
                <para>
                    <note>
                        <para>The plot is always clipped to the plot area.</para>
                    </note>
                </para>
            </sect2>
            <sect2>
                <title>Adjusting the grid lines</title>
                <para>The graph allows several formatting option for the grid lines. For polar plots
                    there are two types of grid lines, the angle and the radius grid lines.</para>
                <para>Grid lines format is controlled by</para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PolarAxis::ShowGrid($aMajor=true,$aMinor=false,$aAngle=true)</code></para>
                            <para>Decide if the major,minor and angle grid line should be displayed
                            </para>
                        </listitem>
                        <listitem>
                            <para><code>PolarAxis::SetGridColor($aMajorColor,$aMinorColor='',$aAngleColor='')</code></para>
                            <para>Specify the color for the major,minor and angel grid</para>
                        </listitem>
                        <listitem>
                            <para><code>PolarAxis::SetAngleStep($aStep) </code></para>
                            <para>This specifies the angle distance between two consecutive angel
                                scale marks in degrees. By default the step size is 15
                                degrees.</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>The two example below shows a logarithmic plot with either just major grid
                    lines or both minor and major grid lines.</para>
                <para>
                    <informaltable frame="none">
                        <tgroup cols="2">
                            <colspec colname="c1" colnum="1"/>
                            <colspec colname="c2" colnum="2"/>
                            <tbody>
                                <row>
                                    <entry>
                                        <programlisting>#=polarex4|Logarithmic scale with only major grid lines#</programlisting>
                                    </entry>
                                    <entry>
                                        <programlisting>#=polarex5|Logarithmic scale with both major and minor grid lines#</programlisting>
                                    </entry>
                                </row>
                            </tbody>
                        </tgroup>
                    </informaltable>
                </para>
            </sect2>
            <sect2>
                <title>Adjusting the labels</title>
                <para>It is possible to individually specify different fonts and colors for the
                    angle and the radius labels. </para>
                <para>
                    <itemizedlist>
                        <listitem>
                            <para><code>PolarAxis::SetFont()</code>
                            </para>
                            <para>Adjust the radius font</para>
                        </listitem>
                        <listitem>
                            <para><code>PolarAxis::SetAngleFont()</code></para>
                            <para>Adjust the radius font</para>
                        </listitem>
                        <listitem>
                            <para><code>PolarAxis::SetColor()</code></para>
                            <para>Adjust the radius color</para>
                        </listitem>
                    </itemizedlist>
                </para>
                <para>The following example specifies different color for the labels. it also shows
                    how to add both a radial axis title as well as a tabbed title. In this example
                    we have also chosen not to show the frame around the edge of the plot.</para>
                <para>
                    <programlisting>#=polarex9|Different colors for labels, specifying both a tabbed title as well as a axis title#</programlisting>
                </para>
                <para>
                    <note>
                        <para>As can be seen from the previous examples the angle labels have a
                            degree mark "¬∞" by default if the font used is a TTF font (the degree
                            symbol is not available for bitmap fonts) after each label. It is
                            possible to select if this degree mark should be displayed or not with a
                            call to the method <code>PolarAxis::SetAngleDegreeMark()</code>.</para>
                    </note>
                </para>
                <para>
                    <note>
                        <para>For the radius labels all standard formatting that can be done to the
                            x-y axis such as format string or format callbacks are supported.</para>
                    </note>
                </para>
                <para>
                    <note>
                        <para>A common modification for polar plots is to disable the display of the
                            last label when using a 360 degree plot since the last label will
                            "collide" with the plot box around the plot area. It is possible to
                            disable the last label with a call to
                                <code>Axis::HideLastTickLabel()</code> As can be see this has been
                            used in some of the examples in this chapter.</para>
                    </note>
                </para>
            </sect2>
        </sect1>
        <xi:include href="section-gantt.xml" parse="xml"/>
    </chapter>
    <xi:include href="chapter-add-graph-types.xml" parse="xml"/>
    <chapter>
        <title>Miscellaneous formatting and tools</title>
        <para>This chapter tries to collect all other formatting options (and tricks) available in
            the library that doesn't really fit anywhere else</para>
        <sect1 xml:id="sec.linear-regression-analysis">
            <title>Linear regression analysis</title>
            <para>The library offers support to do basic linear regression analysis with the help of
                the utility : <code>class LinearRegression</code> defined in the utility module
                    "<filename>jpgraph_utils.inc.php</filename>". With this class it is possible to
                make a linear estimation of data and calculate some of the basic statistics of the
                data, i.e. correlation coefficient and standard error.</para>
            <para>The <code>LinearRegression</code> class is instantiated with the data to be
                analyzed and it is then possible to both get hold of the statistics that corresponds
                to the data and also to automatically calculate a range of estimated y-values for a
                given set of x-coordinates.</para>
            <para>The following code snippet shows how to instantiate a regression analysis with
                some data</para>
            <para>
                <programlisting>&lt;?php
require_once( 'jpgraph_utils.inc.php')

// Some data to be analyzed (both x, and y-data must be specified)
$datay = array( ... ) ;
$datax = array( ... ) ;

// Instantiate the linear regression class
$linreg = new LinearRegression($datax, $datay);

// Get the basic statistics
list( $stderr, $corr ) = $linreg->GetStat();

// Get a set of estimated y-value for x-values in range [0,20]
list($x, $esty) = $linreg->GetY(0,20)

...

?></programlisting>
            </para>
            <para>The methods available in the <code>LinearRegression</code> class that can be used
                are</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>LinearRegression::GetStat()</code></para>
                        <para>Returns an array with (standard error, correlation coefficient,
                            determination coefficient)</para>
                        <para>The closer the correlation coefficient is to 1 the more of the data
                            variation can be explained by a linear estimate.</para>
                    </listitem>
                    <listitem>
                        <para><code>LinearRegression::GetAB()</code></para>
                        <para>Return an array of the linear coefficients (a,b) where the linear
                            estimation is <emphasis role="italic">y = a + b*x</emphasis></para>
                    </listitem>
                    <listitem>
                        <para><code>LinearRegression::GetY($aMinX, $aMaxX, $aStep=1)</code></para>
                        <para>Return an array with (xdata, ydata) corresponding to an x-range
                            between x values in range [<code>$aMinX</code>, <code>$aMaxX</code>]
                            with steps of <code>$aStep</code></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>The following example shows how to use this utility class to plot both the
                original data as well as the estimated linear line.</para>
            <para>
                <programlisting>#example16.6|Linear regression using utility class#</programlisting>
            </para>
        </sect1>
    </chapter>
</part>
