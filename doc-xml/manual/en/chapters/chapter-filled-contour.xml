<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0/rng/docbookxi.rng" type="xml"?>
<chapter
    version="5.0"
    xmlns="http://docbook.org/ns/docbook"
    xmlns:xlink="http://www.w3.org/1999/xlink"
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xml:id="chapter.filled-contour-graphs">
    <title>Filled contour graphs</title>
    <sect1>
        <title>Filled Contour graphs</title>
        <para>
            <note>
                <para>This section describes additional functionality available in the pro-version
                    v3.1p and above.</para>
            </note>
        </para>
        <para>The use of filled ContourPlots requires the inclusion of the module
                "<filename>jpgraph_contourf.php</filename>". The filled version of contour graphs
            supports the following additional features compared to the regular contour graphs</para>
        <para><itemizedlist>
                <listitem>
                    <para>Filled contour plots</para>
                </listitem>
                <listitem>
                    <para>Labelling of isobar lines in the contour plots</para>
                </listitem>
                <listitem>
                    <para>Two user selectable adaptive algorithms to determine the contours, one
                        rectangular and one triangular based adaptive mesh algorithm.</para>
                </listitem>
            </itemizedlist>The enhanced contour plot is contained in the new plot <code>class
                FilledContourPlot</code>.</para>
        <para>As a quick introduction the two examples below shows two contour graphs which makes
            use of these additional features</para>
        <para>
            <informaltable
                frame="void">
                <tbody>
                    <tr>
                        <td>
                            <programlisting>#=contour2_ex1|Filled contour with labels#</programlisting>
                        </td>
                        <td>
                            <programlisting>#=contour2_ex2|Filled contour with no isobar lines#</programlisting>
                        </td>
                    </tr>
                </tbody>
            </informaltable>
        </para>
        <para>All basic formatting, such as specifying colors and number/location of the isobar
            lines are handled in exactly the same way as described in the previous section for basic
            contours.</para>
        <sect2>
            <title>Creating a filled contour graph</title>
            <para>The filled contour graph follows the exact same principles as for the non filled
                graph described above. The core difference is that a filled graph is created as an
                instance of <code>class FilledContourPlot</code>, i.e.</para>
            <para>
                <programlisting>&lt;?php
$filledContour = new FilledContourPlot($data);
?></programlisting>
            </para>
        </sect2>
        <sect2>
            <title>Enabling and disabling contour lines</title>
            <para>Contour lines are controlled with the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>FilledContourPlot::ShowLines($aFlg,$aColorWithFilled='black')</code></para>
                        <para>The <code>$aFlg</code> is a boolean that determines if contour lines
                            should be shown or not. by default they are enabled. The second argument
                                <code>$aColorWithFilled</code> determines what color the contour
                            lines should have when the contour is filled. If the contour is not
                            filled then the contour lines will have the color of the isobar.</para>
                    </listitem>
                </itemizedlist>
            </para>
        </sect2>
        <sect2>
            <title>Specifying a filled contour</title>
            <para>In order to have the contour filled the method</para>
            <itemizedlist>
                <listitem>
                    <para><code>ContourPlot::SetFilled($aFlg)</code> Determines if the contour
                        should be filled or not.</para>
                </listitem>
            </itemizedlist>
            <para>should be called.</para>
            <para>Since there are <emphasis
                    role="italic">n</emphasis> isobar lines and there needs to be <emphasis
                    role="italic">n+1</emphasis> colors to fill the graph there is a choice of what
                side should the color for isobar line <emphasis
                    role="italic">n</emphasis> fill. The area above or the area below the isobar. In
                this library we use the convention that the color for isobar line <emphasis
                    role="italic">n</emphasis> is used to fill the area up to the next highest
                isobar <emphasis
                    role="italic">n+1</emphasis>. </para>
            <para>If the colors are specified manually it is important that one more color than the
                number of isobar lines are specified. The convention is such that the color
                specified in the first position (position = 0 ) in the color array is used to fill
                the area below the lowest specified isobar.</para>
            <para>An example will make this clear.</para>
            <para>The graph below only uses three isobar lines (to keep things simple) which means
                that we need four colors. To create such a graph we use the lines</para>
            <programlisting>&lt;?php
$data = array( ... );

$isobar_colors = array('lightgray','teal:1.3','orange','red');

// Create a new contour graph with three isobar lines
$cp = new ContourPlot($data,3);

// Specify the colors manually
$cp->SetIsobarColors($isobar_colors);

?></programlisting>
            <para>
                <programlisting>#=contour2_ex3|Manual colors for contour#</programlisting>
            </para>
            <para>as can be seen from the labels in the graph the algorithm has resulted in three
                isobar lines (as specified) at values <emphasis
                    role="italic">6.2</emphasis>, <emphasis
                    role="italic">10.5</emphasis> and <emphasis
                    role="italic">14.8</emphasis>. The first color "gray" is used to fill the area
                below the smallest isobar (<emphasis
                    role="italic">6.2</emphasis>).</para>
            <para>It should be noted that by specifying <code>SetFilled(false)</code> a non filled
                contour graph can be created. However, the visual appearance compared with the
                    <code>class ContourPlot</code> will be slightly different. The reason is that
                the filled contour plot class uses an adaptive algorithm that gives better fidelity
                than the simpler non adaptive algorithm used in the standard (non-filled) contour
                plot class. The contour corresponds to creating a contour with the plain contour
                plot algorithm (class ContourPlot) using an interpolation factor of ~3-4.</para>
        </sect2>
        <sect2>
            <title>Adjusting the labels in the contour</title>
            <para>In order to make it easier to follow the contour labels can be added inside the
                contour. The labels are placed using a heuristic algorithm that tries to place
                enough labels to make the plot easy to read but not as many labels as to make it
                crowded.</para>
            <para>There are two main characteristic of the labels that can be controlled.</para>
            <itemizedlist>
                <listitem>
                    <para>The font and color of the labels which are controlled by the two methods
                            <code>FilledContourPlot::SetFont()</code> and
                            <code>FilledContourPlot::SetFontColor()</code></para>
                </listitem>
                <listitem>
                    <para>Whether or not the label should follow the gradient of the isobar line at
                        the point where the label is displayed or if it should always be drawn
                        horizontally.</para>
                </listitem>
            </itemizedlist>
            <para>To enable or disable the display of the labels as well as determining if the label
                should follow the gradient or not the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>FilledContourPlot::ShowLabel($aFlg,$aFollowGradient)</code></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>is used. The two examples below show two variants of the same contour where the
                left graph have labels which follows the gradient and the right graph have labels
                that are always oriented horizontally.</para>
            <para>
                <informaltable
                    frame="void">
                    <tbody>
                        <tr>
                            <td>
                                <programlisting>#=contour2_ex4|Labels that follows the gradients#</programlisting>
                            </td>
                            <td>
                                <programlisting>#=contour2_ex5|Labels that are always horizontal. In this example we have also shown how to change the colors.#</programlisting>
                            </td>
                        </tr>
                    </tbody>
                </informaltable>
            </para>
        </sect2>
        <sect2>
            <title>Selecting the adaptive method to use</title>
            <para>
                <note>
                    <para>This section can be skipped without loss of continuity. The default method
                        "rectangular" recursive adaptation is good enough for most
                        circumstances.</para>
                </note>
            </para>
            <para>In order to fully understand the effect of selecting which adaptive method to use
                it is first necessary to understand some background on how contours are created
                algorithmically. </para>
            <para>Determining general contours for a function of two independent variables is
                equivalent to the problem of finding the equivalence class of all coordinate pairs <emphasis
                    role="italic">(x,y)</emphasis> for which for <emphasis
                    role="italic">C=f(x,y)</emphasis> which in general is a non-linear problem. This
                is an example of a problem that is computational very expensive to mathematically
                solve correct but quite tractable if we view a sampled version of the function. This
                means that we in general do not have access to <emphasis
                    role="italic">f(x,y)</emphasis> instead we only know of its values at a number
                of grid points. This is also the cause of visually different contour plots for the
                same input data.</para>
            <para>The difference lay in the core problem that in order to draw a continues contour
                we need to interpolate the unknown values in between the known sample points. This
                is therefore a degree of freedom where the actual choice of how we do the
                interpolation will cause the contour to be visually different depending on our
                choice.</para>
            <para>While it would take to far in this manual to describe the full adaptive algorithm
                in all details we will show the different principles that underlying the two methods
                hat the user can select between.</para>
            <para>In order to determine the isobars the given data points are considered to be
                vertices in a grid where each vertice is connected with an edge. There are two basic
                ways to connect the points with edges; rectangular and triangular. In the first way
                four points are connected to form a square and in the second way three point are
                connected to form a triangle. The so created square or triangles will be referred to
                as a submesh consisting of four and three sides respectively.</para>
            <para>To determine the isobars each submesh is recursively divided until each side is
                small enough to only have one crossing isobar. The exact position of the crossing is
                determined by linear interpolation between the two corresponding vertices.</para>
            <para>The figures below shows the sequences for the triangle recursive division. The
                recursion continues until each edge has exactly one crossing of an isobar.</para>
            <para>
                <informaltable
                    frame="none">
                    <tgroup
                        cols="3">
                        <colspec
                            colname="c1"
                            colnum="1"/>
                        <colspec
                            colname="c2"
                            colnum="2"/>
                        <colspec
                            colname="c3"
                            colnum="3"/>
                        <tbody>
                            <row>
                                <entry
                                    align="center">
                                    <figure>
                                        <title>Triangulation step 0</title>
                                        <mediaobject>
                                            <imageobject><imagedata
                                                  scale="60"
                                                  fileref="images/tri_step0.png"/></imageobject>
                                        </mediaobject>
                                    </figure>
                                </entry>
                                <entry
                                    align="center">
                                    <figure>
                                        <title>Triangulation step 1</title>
                                        <mediaobject>
                                            <imageobject><imagedata
                                                  scale="60"
                                                  fileref="images/tri_step1.png"/></imageobject>
                                        </mediaobject>
                                    </figure>
                                </entry>
                                <entry
                                    align="center">
                                    <figure>
                                        <title>Triangulation step 2</title>
                                        <mediaobject>
                                            <imageobject><imagedata
                                                  scale="60"
                                                  fileref="images/tri_step2.png"/></imageobject>
                                        </mediaobject>
                                    </figure>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para> In the same way the sequence of figures below shows the principle for the
                quadratic recursive subdivsion of the mesh for first three steps. </para>
            <para>
                <informaltable
                    frame="none">
                    <tgroup
                        cols="3">
                        <colspec
                            colname="c1"
                            colnum="1"/>
                        <colspec
                            colname="c2"
                            colnum="2"/>
                        <colspec
                            colname="c3"
                            colnum="3"/>
                        <tbody>
                            <row>
                                <entry
                                    align="center">
                                    <figure>
                                        <title>"Rectangularization" step 0</title>
                                        <mediaobject>
                                            <imageobject><imagedata
                                                  scale="60"
                                                  fileref="images/rect_step0.png"/></imageobject>
                                        </mediaobject>
                                    </figure>
                                </entry>
                                <entry
                                    align="center">
                                    <figure>
                                        <title>"Rectangularization" step 1</title>
                                        <mediaobject>
                                            <imageobject><imagedata
                                                  scale="60"
                                                  fileref="images/rect_step1.png"/></imageobject>
                                        </mediaobject>
                                    </figure>
                                </entry>
                                <entry
                                    align="center">
                                    <figure>
                                        <title>"Rectangularization" step 2</title>
                                        <mediaobject>
                                            <imageobject><imagedata
                                                  scale="60"
                                                  fileref="images/rect_step2.png"/></imageobject>
                                        </mediaobject>
                                    </figure>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para> Needless to say these two variants give slightly different visual appearance of
                the resulting contour plot and neither of the two method can be considered "the
                right method". Triangularization tends to work better (and faster) for high
                frequency contour plots and gives a more "edgy" result. The quadratic subdivision
                might require more recursive steps for high frequency contours but in general gives
                a smoother look of the resulting contour.</para>
            <para>By default the library uses a rectangular mesh division and that is the method
                that has been used in all the previous examples. As an illustration the effect of
                the method have the two figures below shows the same data as we have used in the
                previous figures to display a contour plot with 7 isobars. The left figures uses a
                rectangular division (the default) and the right figure uses a triangular
                division.</para>
            <para>
                <informaltable
                    frame="none">
                    <tgroup
                        cols="2">
                        <colspec
                            colname="c1"
                            colnum="1"/>
                        <colspec
                            colname="c2"
                            colnum="2"/>
                        <tbody>
                            <row>
                                <entry>
                                    <programlisting>#=contour2_ex6|7 Isobars, "rect" method#</programlisting>
                                </entry>
                                <entry>
                                    <programlisting>#=contour2_ex7|7 Isobars, "tri" method#</programlisting>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </informaltable>
            </para>
            <para>As can be seen in this case the triangular method favour elongated contours from
                southwest to northeast while the rectangular method favours circular contours. </para>
            <para>The way to choose what method to use is by the method</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para><code>FilledContourPlot::SetMethod($aMethod)</code>
                        </para>
                        <para>The possible options for <code>$aMethod</code> are<orderedlist>
                                <listitem>
                                    <para>"rect" - Rectangualr algortihm (default)</para>
                                </listitem>
                                <listitem>
                                    <para>"tri" - Triangular algorithm</para>
                                </listitem>
                            </orderedlist></para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                <tip>
                    <para>It is possible to show the triangulation used by calling the method
                            <code>FilledContourPlot::ShowTriangulation($aFlg)</code>. In the two
                        figures below the triangulation for the "rect" and "tri" method in the
                        previous examples are shown.</para>
                    <para>
                        <informaltable
                            frame="void">
                            <tbody>
                                <tr>
                                    <td>
                                        <figure>
                                            <title>Rectangular sub-division</title>
                                            <mediaobject>
                                                <imageobject><imagedata
                                                  scale="60"
                                                  fileref="images/contour_rectang.png"/></imageobject>
                                            </mediaobject>
                                        </figure>
                                    </td>
                                    <td>
                                        <figure>
                                            <title>Triangular sub-division</title>
                                            <mediaobject>
                                                <imageobject><imagedata
                                                  scale="60"
                                                  fileref="images/contour_triangulation.png"/></imageobject>
                                            </mediaobject>
                                        </figure>
                                    </td>
                                </tr>
                            </tbody>
                        </informaltable>
                    </para>
                </tip>
            </para>
        </sect2>
    </sect1>
</chapter>
